<head>
<link rel="stylesheet" type="text/css" href="style.css">
<!-- <link rel="stylesheet"
      href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.2/styles/default.min.css"> -->
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.2/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
</head>

<h1 id="home">Colin's C++ & Object Oriented Programming Guide</h1>
Using <a href="https://en.wikipedia.org/wiki/Learning_by_teaching">learning by teaching</a> to find gaps in my C++/ OOP knowledge.

<h2>Table of Contents</h2>
<li><a href="#abstraction">Abstraction</li>
<li><a href="#abstract_class">Abstract Class</a></li>
<li><a href="#access_specifiers">Access Specifiers</a></li>
<li><a href="#async_future_promise">Async, Future, and Promise</a></li>
<li><a href="#atomic_datatypes">Atomic Datatypes</a></li>
<li><a href="#auto">Auto</a></li>
<li><a href="#condition_variable">Condition Variables</a></li>
<li><a href="#const">Const</a></li>
<li><a href="#deadlocks">Deadlocks</a></li>
<li><a href="#detached_threads">Detached Threads</a></li>
<li><a href="#threads_vs_processes">Difference between a thread and a process</a></li>
<li><a href="#encapsulation">Encapsulation</li>
<li><a href="#enumerations">Enumerations</a></li>
<li><a href="#final">Final</a></li>
<li><a href="#friend_class">Friend class</a></li>
<li><a href="#friend_function">Friend function</a></li>
<li><a href="#inline">Inline function</a></li>
<li><a href="#interfaces">Interfaces</a></li>
<li><a href="#inheritance">Interitance</li>
<li><a href="#iterators">Iterators</a></li>
<li><a href="#lambda_functions">Lambda Functions</a></li>
<li><a href="#mutexes">Mutexes</a></li>
<li><a href="#no_except">No Except</a></li>
<li><a href="#once_flag">Once_flag</a></li>
<li><a href="#overloading">Overloading</a></li>
<li><a href="#overridding">Overridding</a></li>
<li><a href="#override_keyword">Override Keyword</a></li>
<li><a href="#polymorphism">Polymorphism</a></li>
<li><a href="#predicate">Predicate</a></li>
<li><a href="#inherience_types">Public VS Protected VS Private Inherience</li>
<li><a href="#race_conditions">Race Conditions</a></li>
<li><a href="#raii">RAII</a></li>
<li><a href="#scoped_lock">Scoped Lock</a></li>
<li><a href="#semaphores">Semaphores</a></li>
<li><a href="#shared_lock">Shared Lock</a></li>
<li><a href="#shared_pointers">Shared pointers</a></li>
<li><a href="#singleton_pattern">Singleton Pattern</a></li>
<li><a href="#smart_pointers">Smart Pointers</a></li>
<li><a href="#stl_algorithms">STL Algorithms</a></li>
<li><a href="#terminate">Terminate</a></li>
<li><a href="#threads">Threads</a></li>
<li><a href="#type_generics">Type Generics</a></li>
<li><a href="#unique_locks">Unique Locks</a></li>
<li><a href="#unique_pointers">Unique Pointers</a></li>
<li><a href="#virtual">Virtual</a></li>
<li><a href="#volatile">Volatile</a></li>
<li><a href="#weak_pointers">Weak Pointers</a></li>

<h2 id="abstraction">Abstraction</h2>
<h3>Description</h3>
Abstraction is the process of moving from a specific idea to a more generalized one. Examples include the concept of data types, functions, and abstract classes. 
<h3>Example</h3>
<pre><code>#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

enum COLOR{RED,WHITE,BLUE};

class marble_jar{
  vector&lt;COLOR&gt; contents;
  
  public:
    void add(COLOR c){
        contents.push_back(c);
    }
    
    int num_marbles(){
        return contents.size();
    }
    
    COLOR last_color(){
        return contents[contents.size()-1];
    }
    
};

int main()
{
    marble_jar j;
    
    j.add(RED);
    j.add(RED);
    j.add(BLUE);
    j.add(RED);
    j.add(WHITE);
    
    cout &lt;&lt; j.num_marbles() &lt;&lt; endl;
    cout &lt;&lt; j.last_color() &lt;&lt; endl;

    return 0;
}
</code></pre>
This program outputs:
<pre><code>5
1
</code></pre>

<h2 id="abstract_class">Abstract Class</h2>
<h3>Description</h3>
A class which cannot be initialized but can be used as a base class. A class needs 
atleast one pure virtual function to be an abstract class. Pure virtual functions 
need to be overriden.
<h3>Example</h3>
<pre><code>#include &lt;iostream&gt;

//This is an abstract class
class vehicle{
  virtual void honk() = 0; //pure virtual function
};

class car : vehicle{
  public:
  void honk(){
    std::cout << "beep\n";
  }
};

class truck : vehicle{
  public:
  void honk(){
    std::cout << "honk\n";
  } 
};

int main() {

  //We cannot instantiate the below class because it is abstract
  //vehicle v;

  car c;
  truck t;

  c.honk();
  t.honk();
}
</code></pre>
This program outputs:
<pre><code>beep
honk
</code></pre>

<h2 id="atomic_datatypes">Atomic Datatypes</h2>
<h3>Description</h3>
Atomic datatypes are datatypes that have all of their member functions execute as a single transaction. They are similar to mutexes, except they are signifigantly faster due to cache level optimization. Atomic datatypes do not inherit all of the member functions of their parent datatype. For example, in most cases, mulitply is not overloaded. Overloaded operators are good for making atomic datatypes readable, but in practice the atomic member functions help you write more "correct" code. Atomic member functions include: load(), store(), exchance(), etc.
<h3>Example</h3>
<pre><code>#include &lt;iostream&gt;
#include &lt;thread&gt;
#include &lt;atomic&gt;

using namespace std;

atomic&lt;int&gt; atomic_iter;
int iter = 0;

void update(){
    atomic_iter++;
    iter++;
}

int main()
{
    const auto processor_count = 10;

  thread threads[processor_count];

  for(uint i=0;i&lt;processor_count;i++){
    threads[i] = thread(update);
  }

  for(uint i=0;i&lt;processor_count;i++){
    threads[i].join();
  }
  
  cout &lt;&lt; atomic_iter &lt;&lt; endl; //Cannot have a race condition
  cout &lt;&lt; iter &lt;&lt; endl; //Can have a race condition

    return 0;
}
</code></pre>
This program outputs:
<pre><code>10
10
</code></pre>

<h2 id="condition_variable">Condition Variables</h2>
<h3>Description</h3>
Condition variables allow a thread to atomically release a held mutex
and put itself to sleep. There are two main functions to a condition variable: wait() and
notify_one(). Wait() tells the thread to go to sleep until a notification is available.
Notify_one() sends a signal to one of the sleeping threads to wake up.

There are additional functions. Wait_for and wait_until allows us to cancel a thread's
sleeping to prevent a deadlock. Wait also has an option to take in a predicate to handle
sperious wakeups. We also have notify_all() which works like notify_one(), except it 
notifies all waiting threads instead of just one.
<h3>Example</h3>
<pre><code>#include &lt;iostream&gt;
#include &lt;condition_variable&gt;
#include &lt;thread&gt;
#include &lt;mutex&gt;
#include &lt;string&gt;
#include &lt;queue&gt;
#include &lt;chrono&gt;

using namespace std;

mutex m;
condition_variable cv;

queue&lt;string&gt; food_counter;


int main()
{
    
    for(uint i=0;i&lt;5;i++){
        thread customer([]{
            unique_lock&lt;mutex&gt; ul(m);
            cv.wait(ul);
            food_counter.pop();
            cout &lt;&lt; &quot;A customer ate the food&quot; &lt;&lt; endl;
        });
        customer.detach();
    }
    
    thread chef([]{
        for(uint i=0;i&lt;10;i++){
            unique_lock&lt;mutex&gt; ul(m);
            cout &lt;&lt; &quot;chef made food&quot; &lt;&lt; endl;
            food_counter.push(&quot;food&quot;);
            ul.unlock();
            cv.notify_one();
            std::this_thread::sleep_for(chrono::seconds(1));
        }
    });
    
    
    chef.join();
    
    return 0;
}
</code></pre>
This program outputs:
<pre><code>chef made food
A customer ate the food
chef made food
A customer ate the food
chef made food
A customer ate the food
chef made food
A customer ate the food
chef made food
A customer ate the food
chef made food
chef made food
chef made food
chef made food
chef made food
</code></pre>

<h2 id="const">Const</h2>
<h3>Description</h3>
A keyword that specifies that a variable's value is constant and prevents the programmer from modifying it. To make things more complicated, there are also pointers to consts and const pointers. Pointers to const can have thier address change, but not their value. Const pointers can have their values changed, but not their addresses.
<h3>Example</h3>
<pre><code>int main(){
    int a = 1;
    int b = 2;
    
    //Standard const
    const int test1 = a;
    //test1 = b; //Not allowed
    
    //Pointer to const
    const int* test2 = &amp;a;
    test2 = &amp;b; //Allowed
    //*test2 = b; //Not allowed
    
    //Pointer to const
    int* const test3 = &amp;a;
    *test3 = b; //Allowed
    //test3 = &amp;b; //Not allowed    
}
</pre></code>

<h2 id="deadlocks">Deadlocks</h2>
<h3>Description</h3>
A deadlock is any situation in which two or more threads are blocked indefinitely. For example, lets say there are two threads, t1 and t2, and two resources, r1 and r2. 
T1 and t2 both will not finish their execution unless they have both resource r1 and r2 locked. If t1 locks r1 and t2 locks r2, then neither thread will ever finish resulting in a
deadlock.
<h3>Example</h3>
<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;thread&gt;
#include &lt;mutex&gt;
#include &lt;unistd.h&gt;

using namespace std;

mutex chopstick1;
mutex chopstick2;

void eat1(){
    
    lock_guard&lt;mutex&gt; g1(chopstick1);
    usleep(1 * 1000000);
    lock_guard&lt;mutex&gt; g2(chopstick2);
    
    cout &lt;&lt; &quot;burp&quot; &lt;&lt; endl;
}

void eat2(){
    
    lock_guard&lt;mutex&gt; g2(chopstick2);
    usleep(1 * 1000000);
    lock_guard&lt;mutex&gt; g1(chopstick1);
    
    cout &lt;&lt; &quot;burp&quot; &lt;&lt; endl;
}


int main(){
    thread t1 = thread(eat1);
    thread t2 = thread(eat2);
    t1.join();
    t2.join();
}
</code></pre>

<h2 id="threads_vs_processes">Difference between a thread and a process</h2>
<h3>Description</h3>
A thread is a sequence of instructions executed concurrently and is part of a process. A process is an instance of a program. Threads are "lighter" than processes. They require less time for context switching and require less resources. Threads share resources, unlike processes. Processes collabrate less with each other compared to threads.
<h3>Example</h3>
<pre><code>#include &lt;iostream&gt;
#include &lt;thread&gt;
#include &lt;unistd.h&gt; 

using namespace std;

const uint NUM_THREADS = 3;
pid_t* pid = (pid_t*)malloc(sizeof(pid_t));

void task1(int id){
  printf(&quot;Process #%d, Thread #%dn&quot;,*pid,id);
}

int main(){

  //fork() creates a new process
  pid[0] = fork(); 

  thread threads[NUM_THREADS];

  for(int i=0;i&lt;NUM_THREADS;i++){
    //thread() creates a new thread
    threads[i] = thread(task1, i); 
  }

  for(int i=0;i&lt;NUM_THREADS;i++){
    threads[i].join();
  }
}
</code></pre>
This program outputs:
<pre><code>Process #0, Thread #0
Process #0, Thread #1
Process #1136, Thread #0
Process #1136, Thread #2
Process #0, Thread #2
Process #1136, Thread #1
</code></pre>

<h2 id="encapsulation">Encapsulation</h2>
<h3>Description</h3>
Encapsulation is the binding of data with the functions which manipulate them. Encapsulation
reduces complexity, protects our data, and makes our classes easier to change. Through data hiding,
encapsulation leads to more abstraction.

<h2 id="detached_threads">Detached Threads</h2>
<h3>Description</h3>
Detached threads are threads that have had their "detached()" member function called. They cannot be joined. When a detached thread is done, its resources are destroyed safely.
<h3>Example</h3>
<pre><code>#include &lt;iostream&gt;
#include &lt;thread&gt;
#include &lt;unistd.h&gt;

using namespace std;

int main ()
{
  thread t1([]{
     cout &lt;&lt; &quot;t1 started&quot; &lt;&lt; endl;
     sleep(3);
     cout &lt;&lt; &quot;t1 done&quot; &lt;&lt; endl;
  });
  
  thread t2([]{
     cout &lt;&lt; &quot;t2 started&quot; &lt;&lt; endl;
     sleep(2);
     cout &lt;&lt; &quot;t2 done&quot; &lt;&lt; endl;
  });
  
  thread t3([]{
     cout &lt;&lt; &quot;t3 started&quot; &lt;&lt; endl;
     sleep(1);
     cout &lt;&lt; &quot;t3 done&quot; &lt;&lt; endl;
  });
  
  t1.detach();
  t2.detach();
  t3.detach();
  
  sleep(5);

  return 0;
}
</code></pre>
This program outputs:
<pre><code>t1 started
t3 started
t2 started
t3 done
t2 done
t1 done
</code></pre>

<h2 id="enumerations">Enumerations</h2>
<h3>Description</h3>
A user defined set of named constants. It is a way of associating names with integers.
<h3>Example</h3>
<pre><code>#include &lt;iostream&gt;

enum temperature {cold, lukewarm, hot};
enum direction {East=0, West=180, North=90, South=270};

int main() {
  temperature temp1 = cold;
  temperature temp2 = hot;

  direction direction1 = East;
  direction direction2 = South;

  std::cout &lt;&lt; temp1 &lt;&lt; std::endl;
  std::cout &lt;&lt; temp2 &lt;&lt; std::endl;
  std::cout &lt;&lt; direction1 &lt;&lt; std::endl;
  std::cout &lt;&lt; direction2 &lt;&lt; std::endl;
}
</code></pre>
This program outputs:
<pre><code>0
2
0
270
</code></pre>

<h2 id="inline">Inline Functions</h2>
<h3>Description</h3>
Forces the compilier to directly replace function calls with the contents of the function. This allows faster runtimes for functions that are small and called often.
<h3>Example</h3>
<pre><code>#include &lt;iostream&gt;
#include &lt;chrono&gt;
#include &lt;thread&gt;
#include &lt;iostream&gt;
#include &lt;float.h&gt;

using namespace std;

double small_increase(double a){
    return a*1.00001;
}    

inline double inline_small_increase(double a){
    return a*1.00001;
}    

int main(){
    
    double x = 2;
    double y = 2;
    
    auto t1 = chrono::high_resolution_clock::now();
    while(x &lt; DBL_MAX){
        x = small_increase(x);
    }
    auto t2 = chrono::high_resolution_clock::now();
    while(y &lt; DBL_MAX){
        y = inline_small_increase(x);
    }
    auto t3 = chrono::high_resolution_clock::now();
    
    cout &lt;&lt; &quot;non-inline took &quot;
              &lt;&lt; chrono::duration_cast&lt;std::chrono::milliseconds&gt;(t2-t1).count()
              &lt;&lt; &quot; milliseconds&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;inline took &quot;
              &lt;&lt; chrono::duration_cast&lt;std::chrono::milliseconds&gt;(t3-t2).count()
              &lt;&lt; &quot; milliseconds&quot; &lt;&lt; endl;
}
</code></pre>
This program outputs:
<pre><code>non-inline took 132 milliseconds
inline took 0 milliseconds
</code></pre>

<h2 id="interfaces">Interfaces</h2>
<h3>Description</h3>
<h3>Example</h3>
<pre><code>Interfaces are used to separate the declaration from the implementation. Implementation of an interface is done with run-time polymorphism. An abstract class that only has pure abstract classes is an interface. Pure virtual functions are virtual functions which end in "=0";
</code></pre>
<h3>Example</h3>#include &#x3C;iostream&#x3E;

using namespace std;

class person{
    public:
    virtual void speak() = 0;
    virtual int getSalary() = 0;
};

class teacher : person{
    public: 
    void speak(){
        cout &#x3C;&#x3C; &#x22;Today&#x27;s lesson is...&#x22; &#x3C;&#x3C; endl;
    }
    int getSalary(){
        return 50000;
    }
};

class student : person{
    public:
    void speak(){
        cout &#x3C;&#x3C; &#x22;I love learning&#x22; &#x3C;&#x3C; endl;
    }
    int getSalary(){
        return 0;
    }
};

int main ()
{
  teacher t;
  student s;
  t.speak();
  s.speak();

  return 0;
}
</code></pre>
This program outputs:
<pre><code>Today's lesson is...
I love learning
</code></pre>

<h2 id="inheritance">Inheritance</h2>
<h3>Description</h3>
Inheritance is when you define a class in terms of another class. It allows us to write less code. Less code = less opportunities 
for bugs. Inheritance is a "is a" relationship. For example, a vehicle IS A car. There are three kinds of inheritance: public,
protected, and private. A derived class inherits all of the base class's methods except for: constructors, destructors, copy constructors, 
overloaded operators, and friend functions. 
<h3>Example</h3>
<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;

using namespace std;

class edible{
    public:
    int calories;
};

class animal{
    public:
    int consumed_calories = 0;
    virtual void eat(edible e) = 0;
};

class tiger : public animal{
    public:
    void eat(edible e){
        consumed_calories += e.calories;
        cout &lt;&lt; &quot;The tiger has &quot; &lt;&lt; consumed_calories &lt;&lt; &quot; total calories&quot; &lt;&lt; endl;
    }
};

class rabbit : public edible, public animal{
    public:
    void eat(edible e){
        consumed_calories += e.calories;
        cout &lt;&lt; &quot;The rabbit has &quot; &lt;&lt; consumed_calories &lt;&lt; &quot; total calories&quot; &lt;&lt; endl;
    }
    
    rabbit(){
        calories = 5000;
    }
};

class grass : public edible{
    public:
    grass(){
        calories = 1;
    }
};

int main()
{
    tiger t1;
    rabbit r1;
    grass g1;
    grass g2;
    grass g3;
    
    r1.eat(g1);
    r1.eat(g1);
    r1.eat(g1);
    t1.eat(r1);

    return 0;
}
</code></pre>
This program outputs:
<pre><code>The rabbit has 1 total calories                                                                                                                                              
The rabbit has 2 total calories                                                                                                                                              
The rabbit has 3 total calories                                                                                                                                              
The tiger has 5000 total calories
</code></pre>

<h2 id="iterators">Iterators</h2>
<h3>Description</h3>
Any object that points to some element and has the ability to iterate through the 
elements with the operators "++"(increment) and "*"(dereference).
<h3>Example</h3>
<pre><code>#include &lt;iostream&gt;
#include &lt;iterator&gt;
#include &lt;vector&gt;
#include &lt;deque&gt;

//This function returns the mean of a iterable container
template &lt;class InputIterator, class T&gt; double mean(InputIterator first, InputIterator last, T init){

  T output = 0;
  double count = 0;

  while (first!=last) {
    output += *first;
    first++;
    count++;
  }
  return output/count;
}

int main() {
  std::vector&lt;int&gt; v = {1,2,3,4};
  std::deque&lt;double&gt; d = {5.1,5.2,5.3};
  std::cout &lt;&lt; mean(v.begin(),v.end(),0) &lt;&lt; std::endl;
  std::cout &lt;&lt; mean(d.begin(),d.end(),0.0) &lt;&lt; std::endl;
}
</code></pre>
This program outputs:
<pre><code>2.5
5.2
</code></pre>

<h2 id="lambda_functions">Lambda Functions</h2>
<h3>Description</h3>
A function written in line without an identifier. Functions without idenfifiers 
are called "anonymous functions". Anonymous functions can only be invoked once.
<h3>Example</h3>
<pre><code>#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

typedef struct rectangle{
  double width;
  double height;
} rectangle;

int main(){

    vector&lt;rectangle&gt; rects;
    rectangle r1 = {0,1};
    rects.push_back(r1);
    rectangle r2 = {3,3};
    rects.push_back(r2);
    rectangle r3 = {1,2};
    rects.push_back(r3);
    rectangle r4 = {4,4};
    rects.push_back(r4);
    rectangle r5 = {2,1};
    rects.push_back(r5);
    
    sort(rects.begin(), rects.end(), [](const rectangle&amp; a, const rectangle&amp; b) -&gt; bool{ 
        return a.width * a.height &lt; b.width * b.height; 
    }); 
    
    cout &lt;&lt; &quot;width, height&quot; &lt;&lt; endl;
    for(auto &amp;v:rects){
        cout &lt;&lt; v.width &lt;&lt; &quot;, &quot; &lt;&lt; v.height &lt;&lt; endl;
    }
    
    return 0;
}
</code></pre>
This program outputs:
<pre><code>width, height
0, 1
1, 2
2, 1
3, 3
4, 4
</code></pre>

<h2 id="mutexes">Mutexes</h2>
<h3>Description</h3>
Lockable objects that are designed to signal when critical sections of code require
exclusive access. They lock when they get to the critical section and unlock once they
are done with it.
<h3>Example</h3>
<pre><code>#include &lt;iostream&gt;
#include &lt;thread&gt;
#include &lt;mutex&gt;
#include &lt;unistd.h&gt;

const uint NUM_THREADS = 3;

using namespace std;

mutex m;

void hello_without_mutex(uint id) {
  cout &lt;&lt; &quot; Hello&quot;;
  usleep(1000);
  cout &lt;&lt; &quot; I am &quot;;
  cout &lt;&lt; id &lt;&lt; endl;
}

void hello_with_mutex (uint id) {
  lock_guard&lt;std::mutex&gt; g(m); 
  cout &lt;&lt; &quot; Hello&quot;;
  usleep(1000);
  cout &lt;&lt; &quot; I am &quot;;
  cout &lt;&lt; id &lt;&lt; endl;
}

int main() {

  cout &lt;&lt; &quot;Without Mutexes:&quot; &lt;&lt; endl;

   thread threads1[NUM_THREADS];
   for(uint i=0;i&lt;NUM_THREADS;i++){
     threads1[i] = thread(hello_without_mutex,i);
   }

   for(int i=0;i&lt;NUM_THREADS;i++){
     threads1[i].join();
   }
   
   cout &lt;&lt; endl;
   cout &lt;&lt; &quot;With Mutexes:&quot; &lt;&lt; endl;

   thread threads2[NUM_THREADS];
   for(uint i=0;i&lt;NUM_THREADS;i++){
     threads2[i] = thread(hello_with_mutex,i);
   }

   for(int i=0;i&lt;NUM_THREADS;i++){
     threads2[i].join();
   }
}
</code></pre>
This program outputs:
<pre><code>Without Mutexes:
 Hello Hello Hello I am 0
 I am 2
 I am 1

With Mutexes:
 Hello I am 0
 Hello I am 2
 Hello I am 1
</code></pre>

<h2 id="inherience_types">Predicate</h2>
<h3>Description</h3>
Predicates are any callable function which returns a bool. Many STL algorithms use
predicates as input. For example, all_of(), any_of(), and none_of().

<h2 id="inherience_types">Public VS Protected VS Private Inherience</h2>
<h3>Description</h3>
Public inheritance has everything able to access everything of the base class. Protected inheritance only has the children able to access everything of the base class. Private inheritance only allows the parent to have access to everything. Default inheritance is private.
<h3>Example</h3>
<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;

using namespace std;

class public_child{
    public:
        string a = &quot;public childred&quot;; 
};

class protected_child{
    public:
        string b = &quot;protected childred&quot;; 
};

class private_child{
    public:
        string c = &quot;private childred&quot;; 
};

class A : public public_child, protected protected_child, private private_child{
    
    public:
        string get_b(){
            return b;
        }
        
        string get_c(){
            return c;
        }
        
};

class B : A {
    
    public:
        string get_a(){
                return b;
        }
        
        string get_b(){
                return b;
        }
};

int main()
{
  A test;
  cout &lt;&lt; test.a &lt;&lt; &quot; can access directly&quot; &lt;&lt; endl;
  cout &lt;&lt; test.get_b() &lt;&lt; &quot; and &quot; &lt;&lt; test.get_c() &lt;&lt; &quot; need getters&quot; &lt;&lt; endl;
  B test2;
  cout &lt;&lt; test2.get_a() &lt;&lt; &quot; and &quot; &lt;&lt; test2.get_b() 
  &lt;&lt; &quot; can be printed by children of the base class&quot; &lt;&lt; endl;
}
</code></pre>
This program outputs:
<pre><code>public childred can access directly
protected childred and private childred need getters
protected childred and protected childred can be printed by children of the base class
</code></pre>

<h2 id="race_conditions">Race Conditions</h2>
<h3>Description</h3>
A race condition is when two or more threads try to read or write a piece of data
and atleast one of those threads is writing. Race conditions result in undefined behavior. The 
cure for a race condition, most of the time, is mutexes.
<h3>Example</h3>
<pre><code>#include &lt;iostream&gt;
#include &lt;thread&gt;
#include &lt;unistd.h&gt;
#include &lt;stack&gt;

using namespace std;

std::stack&lt;int&gt; s;

void remove_add_1(){
    //MUTEX HERE WOULD PREVENT RACE CONDITION
    s.pop();
    usleep(1000);
    s.push(1);
    cout &lt;&lt; s.top() &lt;&lt; endl;
}

int main(){
    
    s.push(0);
    
    thread readers[10];
    
    for(int i=0;i&lt;10;i++){
        readers[i] = thread(remove_add_1);
    }
    
    for(int i=0;i&lt;10;i++){
        readers[i].join();
    }
}
</code></pre>
This program outputs:
<pre><code>Created
Segmentation Fault
</code></pre>

<h2 id="raii">RAII</h2>
<h3>Description</h3>
Stands for "Resource Acquistion Is Initialization". This is a terrible name for a 
great concept. A better name for RAII would be "Scope Based Memory Management". 
The resource allocation is done at initialization by the constructor and the resource 
deallocation is done at finalization by the destructor. 
<h3>Example</h3>
<pre><code>#include &lt;iostream&gt;
#include &lt;memory&gt;

class true_false_exam{
  public:
  bool* answers;

  true_false_exam(){
    answers = new bool(100); 
    std::cout &lt;&lt; &quot;Created&quot; &lt;&lt; std::endl;
  }

  ~true_false_exam(){
    delete (answers);
    std::cout &lt;&lt; &quot;Deleted&quot; &lt;&lt; std::endl;
  }
};

int main() {
  //Unique pointer will automatically call the deconstructor
  //once the object is out of scope
  std::unique_ptr&lt;true_false_exam&gt; t(new true_false_exam());
}
</code></pre>
This program outputs:
<pre><code>Created
Deleted
</code></pre>

<h2 id="semaphores">Semaphores</h2>
<h3>Description</h3>
Used to control access to a common resource. When you create a semaphore you give
it a starting resource count. Every time we use a resource we decrement from the resource
count. Every time we are done with the resource we increment. If the resource count is
less than zero, when we want the resource, then we must wait until the resource count is greater than 
or equal to zero. 
<br><br>
Semaphores which allow an arbitrary resource count are called "counting semaphores". 
Semaphores which are either locked or unlocked are called "binary semaphores". Binary semaphores
can be used as a mutex.
<h3>Example</h3>
<pre><code>#include &lt;iostream&gt;
#include &lt;pthread.h&gt;
#include &lt;vector&gt;
#include &lt;mutex&gt;

using namespace std;

const uint NUM_THREADS = 5;

class semaphore{
    
    private: 
        pthread_mutex_t lock;
        pthread_cond_t wait;
        int value;
        
        
    public: 
    
        semaphore(int v){
            value = v;
            pthread_cond_init(&amp;wait,NULL);
            pthread_mutex_init(&amp;lock,NULL);
        }
        
        void P(){
            value--;
            if(value &lt; 0) {
                pthread_cond_wait(&amp;wait,&amp;lock);
            }
            pthread_mutex_unlock(&amp;lock);
        }
        
        void V(){
            pthread_mutex_lock(&amp;lock);
            value++;
            if(value &lt;= 0) {
                pthread_cond_signal(&amp;wait);
            }
            pthread_mutex_unlock(&amp;lock);
        }

};

semaphore* s = new semaphore(2);

void *test_func(void *input) {
    
    int id = *((int*)(&amp;input));
    
    printf(&quot;%d is inn&quot;,id);
    s-&gt;P();
    
    for(int wasting_time=0;wasting_time&lt;1000000000*id;wasting_time++);

    s-&gt;V();
    printf(&quot;%d is outn&quot;,id);
    
    return NULL;
}

int main(){   
    pthread_t threads[NUM_THREADS];
    
    //Starting each thread
    for(uint i = 0; i &lt; NUM_THREADS; i++) {
        pthread_create(&amp;threads[i], NULL, test_func, (void*)i);
    }

    //Stopping and collecting data from each thread
    for(uint i = 0; i &lt; NUM_THREADS; i++) {
        pthread_join(threads[i], NULL);
    }
}
</code></pre>
This program outputs:
<pre><code> 0 is in
  0 is out
  2 is in
  4 is in
  4 is out
  2 is out
  1 is in
  1 is out
  3 is in
  3 is out
</code></pre>

<h2 id="smart_pointers">Smart Pointer</h2>
<h3>Description</h3>
Similar to a pointer except it has automatic memory management. Once the scope
of the smart pointer ends, the program knows to destory the pointer. There are currently
three kinds of smart pointers: "unique_ptr", "shared_ptr", and "weak_ptr". There used
to be an "auto_ptr", but this was deprecated in c++11 and removed in c++17.
  <h4 id="unique_pointers">Unique Pointers</h4>
  Owns and manages another object through a pointer and disposes of it when the
  pointer goes out of scope. If you try to make a copy of a unique pointer, the
  compilier will give you an error.
  <h4 id="shared_pointers">Shared Pointers</h4>
  Same thing as a unique pointer, except you are allowed to make copies.
  <h4 id="weak_pointers">Weak Pointers</h4>
  Smart pointer that has a non-owning("weak") reference to an object that is a
  shared pointer.
<h3>Example</h3>
<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;memory&gt;

class named_object{

  public:

    std::string name;

    named_object(std::string n){
      name = n;
      std::cout &lt;&lt; name &lt;&lt; &quot; created&quot; &lt;&lt; std::endl;
    }

    ~named_object(){
      std::cout &lt;&lt; name &lt;&lt; &quot; deleted&quot; &lt;&lt; std::endl;
    }
};

int main() {
  //The raw pointer is not deleted correctly because it is not "smart"
  named_object* raw = new named_object(&quot;raw pointer&quot;); 

  //The unique, shared, and weak pointers below are deleted correctly
  //because they are "smart"
  std::unique_ptr&lt;named_object&gt; unique(new named_object(&quot;unique&quot;));
  std::shared_ptr&lt;named_object&gt; shared(new named_object(&quot;shared&quot;));
  std::shared_ptr&lt;named_object&gt; shared2 = shared;
  std::weak_ptr&lt;named_object&gt; weak = shared2;
}
</code></pre>
This program outputs:
<pre><code>raw pointer created
unique created
shared created
shared deleted
unique deleted
</code></pre>

<h2 id="type_generics">Type Generics</h2>
<h3>Description</h3>
Allows you write code without stating the actual data type. The use of generics is commonly seen in data structures like array and vector. Generics make our code more reusable.
<h3>Example</h3>
<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;

using namespace std;

template &lt;typename T&gt; T myAbs(T a){
    if(a &lt; 1) a *= -1;
    return a;
}

int main(){
    double x = -1.2;
    int y = 100;
    float z = -20.9;
    
    cout &lt;&lt; myAbs(x) &lt;&lt; endl;
    cout &lt;&lt; myAbs(y) &lt;&lt; endl;
    cout &lt;&lt; myAbs(z) &lt;&lt; endl;
}
</code></pre>
This program outputs:
<pre><code>1.2
100
20.9
</code></pre>

<h2 id="unique_locks">Unique Locks</h2>
<h3>Description</h3>
Unique locks on construction locks a mutex and on destruction unlocks a mutex. Unique locks
differs from lock guards, because they can be unlocked.

<h2 id="threads">Threads</h2>
<h3>Description</h3>
A sequence of instructions which can be executed concurrently. Each thread is 
given a function to run and parameters for its function. A join function is used to
finish the thread and collect its returned data. Threads have the risks of errors
due to things like race condidtions. However concurrency can greatly improve the
run time of your program.
<h3>Example</h3>
<pre><code>#include &lt;iostream&gt;
#include &lt;cstdlib&gt;
#include &lt;pthread.h&gt;

using namespace std;

const uint NUM_THREADS = 5;

//Data for each thread
struct thread_data{
  int thread_id;
  int input;
};

//Function which each thread will do
void *calc_part(void *input) {

  thread_data* ptr = (thread_data*)input;
  int n = ptr-&gt;thread_id;
  int m = ptr-&gt;input;

  int* thread_sum = (int*)malloc(sizeof(int));

  thread_sum[0] = 1;

  for(int i=1;i&lt;=m;i++){
    if(i%NUM_THREADS == n){
      thread_sum[0] *= i;
    }
  }

  //Using printf instead to prevent race conditions
  printf(&quot;  Thread  #%d returns %dn&quot;,n,thread_sum[0]);
  pthread_exit(thread_sum);
}

int factorial(int x){

  cout &lt;&lt; &quot;Input is &quot; &lt;&lt; x &lt;&lt; endl;

  if(x==0){
    cout &lt;&lt; &quot;Output is 0&quot; &lt;&lt; endl;
    return 0;
  }

  int output = 1;

  pthread_t threads[NUM_THREADS];

  int** results = (int**)malloc(sizeof(int) * NUM_THREADS);

  //Setting up the data for each thread
  thread_data* thread_datas = (thread_data*)malloc(sizeof(thread_data) * NUM_THREADS);
  for(int i = 0; i &lt; NUM_THREADS; i++) {
    thread_data d; 
    d.thread_id = i;
    d.input = x;
    thread_datas[i] = d;
  }

  //Starting each thread
  for(int i = 0; i &lt; NUM_THREADS; i++) {
    pthread_create(&amp;threads[i], NULL, calc_part, &amp;thread_datas[i]);
  }

  //Stopping and collecting data from each thread
  for(int i = 0; i &lt; NUM_THREADS; i++) {
    pthread_join(threads[i], (void**)&amp;results[i]);
    output *= results[i][0];
  }

  cout &lt;&lt; &quot;Output is &quot; &lt;&lt; output &lt;&lt; endl;
  return output;
}

int main () {
  factorial(1);
  factorial(2);
  factorial(5);
  factorial(10);
}
</code></pre>

This program outputs:
<pre><code>Input is 1
  Thread  #1 returns 1
  Thread  #2 returns 1
  Thread  #0 returns 1
  Thread  #3 returns 1
  Thread  #4 returns 1
Output is 1
Input is 2
  Thread  #0 returns 1
  Thread  #3 returns 1
  Thread  #4 returns 1
  Thread  #2 returns 2
  Thread  #1 returns 1
Output is 2
Input is 5
  Thread  #4 returns 4
  Thread  #2 returns 2
  Thread  #3 returns 3
  Thread  #1 returns 1
  Thread  #0 returns 5
Output is 120
Input is 10
  Thread  #2 returns 14
  Thread  #1 returns 6
  Thread  #0 returns 50
  Thread  #3 returns 24
  Thread  #4 returns 36
Output is 3628800
</code></pre>

<h2 id="volatile">Volatile</h2>
<h3>Description</h3>
Prevents the addresses from being optimized away. Volatile is needed for embedded development where the hardware device is memory-mapped and memory may change without the compilier knowing.
<h3>Example</h3>
<pre><code>int main(){
    
    //The compiler may optimize the while loop into &quot;while(true)&quot;
    int a = 100;
    while(a == 100){}
    
    //The compliler will not &quot;optimize away&quot; the b variable
    volatile int b = 100;
    while(b == 100){}
} 
</code></pre>
