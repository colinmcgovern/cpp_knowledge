<head>
<link rel="stylesheet" type="text/css" href="style.css">
<!-- <link rel="stylesheet"
      href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.2/styles/default.min.css"> -->
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.2/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<title>Colin's C++ & Object Oriented Programming Guide</title>
</head>

<h1 id="home">Colin's C++ & Object Oriented Programming Guide</h1>
Using <a href="https://en.wikipedia.org/wiki/Learning_by_teaching">learning by teaching</a> to find gaps in my C++/ OOP knowledge. <i>"C++ is a general-purpose programming language with a bias towards systems programming that is better than C, supports data abstraction, supports object-oriented programming and supports generic programming"</i> -Bjarne Stroustrup

<!-- GOTO Top button start -->
<button onclick="topFunction()" id="goto_top" title="Go to top">Go To Top</button>

<script>
//Get the button
var mybutton = document.getElementById("goto_top");

// When the user scrolls down 20px from the top of the document, show the button
window.onscroll = function() {scrollFunction()};

function scrollFunction() {
  if (document.body.scrollTop > 20 || document.documentElement.scrollTop > 20) {
    mybutton.style.display = "block";
  } else {
    mybutton.style.display = "none";
  }
}

// When the user clicks on the button, scroll to the top of the document
function topFunction() {
  document.body.scrollTop = 0;
  document.documentElement.scrollTop = 0;
}
</script>
<!-- GOTO Top button stop -->

<h2>Table of Contents</h2>
<li><a href="#abstraction">Abstraction</li>
<li><a href="#abstract_class">Abstract Class</a></li>
<li><a href="#access_specifiers">Access Specifiers</a></li>
<li><a href="#async_future_promise">Async, Future, and Promise</a></li>
<li><a href="#atomic_datatypes">Atomic Datatypes</a></li>
<li><a href="#auto">Auto</a></li>
<li><a href="#condition_variable">Condition Variables</a></li>
<li><a href="#const">Const</a></li>
<li><a href="#context_switching">Context Switching</a></li>
<li><a href="#deadlocks">Deadlocks</a></li>
<li><a href="#dependency_injection">Dependency Injection</a></li>
<li><a href="#detached_threads">Detached Threads</a></li>
<li><a href="#diamond_problem">Diamond Problem of Inheritance</a></li>
<li><a href="#threads_vs_processes">Difference between a thread and a process</a></li>
<li><a href="#encapsulation">Encapsulation</li>
<li><a href="#enumerations">Enumerations</a></li>
<li><a href="#factory_method">Factory Method</a></li>
<li><a href="#final">Final</a></li>
<li><a href="#friend_class">Friend class</a></li>
<li><a href="#friend_function">Friend function</a></li>
<li><a href="#inline">Inline function</a></li>
<li><a href="#interfaces">Interfaces</a></li>
<li><a href="#inheritance">Interitance</li>
<li><a href="#iterators">Iterators</a></li>
<li><a href="#lambda_functions">Lambda Functions</a></li>
<li><a href="#mutexes">Mutexes</a></li>
<li><a href="#no_except">No Except</a></li>
<li><a href="#once_flag">Once_flag</a></li>
<li><a href="#overloading">Overloading</a></li>
<li><a href="#overridding">Overridding</a></li>
<li><a href="#override_keyword">Override Keyword</a></li>
<li><a href="#pimpl">PIMPL Idiom</a></li>
<li><a href="#polymorphism">Polymorphism</a></li>
<li><a href="#predicate">Predicate</a></li>
<li><a href="#inherience_types">Public VS Protected VS Private Inherience</li>
<li><a href="#race_conditions">Race Conditions</a></li>
<li><a href="#raii">RAII</a></li>
<li><a href="#reference_vs_pointer">Reference vs Pointer</a></li>
<li><a href="#scoped_lock">Scoped Lock</a></li>
<li><a href="#semaphores">Semaphores</a></li>
<li><a href="#shared_lock">Shared Lock</a></li>
<li><a href="#shared_pointers">Shared pointers</a></li>
<li><a href="#singleton_pattern">Singleton Pattern</a></li>
<li><a href="#smart_pointers">Smart Pointers</a></li>
<li><a href="#static_vs_dynamic_memory">Static vs Dynamic Memory</a></li>
<li><a href="#stl_algorithms">STL Algorithms</a></li>
<li><a href="#terminate">Terminate</a></li>
<li><a href="#threads">Threads</a></li>
<li><a href="#type_generics">Type Generics</a></li>
<li><a href="#unique_locks">Unique Locks</a></li>
<li><a href="#unique_pointers">Unique Pointers</a></li>
<li><a href="#vector_vs_list_vs_array">Vector vs List vs Array</a></li>
<li><a href="#virtual">Virtual</a></li>
<li><a href="#volatile">Volatile</a></li>
<li><a href="#weak_pointers">Weak Pointers</a></li>
<li><a href="#thread_safe_functions">What makes a function "thread-safe"?</a></li>

<h2 id="abstraction">Abstraction</h2>
<h3>Description</h3>
Abstraction is the process of moving from a specific idea to a more generalized one. Examples include the concept of data types, functions, and abstract classes. 
<h3>Example</h3>
<pre><code>#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

enum COLOR{RED,WHITE,BLUE};

class marble_jar{
  vector&lt;COLOR&gt; contents;
  
  public:
    void add(COLOR c){
        contents.push_back(c);
    }
    
    int num_marbles(){
        return contents.size();
    }
    
    COLOR last_color(){
        return contents[contents.size()-1];
    }
    
};

int main()
{
    marble_jar j;
    
    j.add(RED);
    j.add(RED);
    j.add(BLUE);
    j.add(RED);
    j.add(WHITE);
    
    cout &lt;&lt; j.num_marbles() &lt;&lt; endl;
    cout &lt;&lt; j.last_color() &lt;&lt; endl;

    return 0;
}
</code></pre>
This program outputs:
<pre><code>5
1
</code></pre>

<h2 id="abstract_class">Abstract Class</h2>
<h3>Description</h3>
A class which cannot be initialized but can be used as a base class. A class needs 
atleast one pure virtual function to be an abstract class. Pure virtual functions 
need to be overriden.
<h3>Example</h3>
<pre><code>#include &lt;iostream&gt;

//This is an abstract class
class vehicle{
  virtual void honk() = 0; //pure virtual function
};

class car : vehicle{
  public:
  void honk(){
    std::cout << "beep\n";
  }
};

class truck : vehicle{
  public:
  void honk(){
    std::cout << "honk\n";
  } 
};

int main() {

  //We cannot instantiate the below class because it is abstract
  //vehicle v;

  car c;
  truck t;

  c.honk();
  t.honk();
}
</code></pre>
This program outputs:
<pre><code>beep
honk
</code></pre>

<h2 id="access_specifiers">Access Specifiers</h2>
<h3>Description</h3>
Access specifiers are used in classes to define what its encapsulation behavior should be. There are three access specifiers in C++: public, private, and protected. Public class members are accessible to everyone. Private class members are accessible to no one. Protected is just like private, except they are accessible to the class's children. 
<h3>Example</h3>
<pre><code>#include &#x3C;iostream&#x3E;
#include &#x3C;vector&#x3E;

using namespace std;

class feline{
    
    private:
        string name;
        
    protected:
        int danger_level;
    
    public:     
        string getName(){
            return name;
        }
        
        void setName(string n){
            name = n;
        }    
        
        int getDanger_level(){
            return danger_level;
        }
};

class house_cat : public feline{
    
    public:
        house_cat(){
            danger_level = 1;
        }
    
};

class lion : public feline{
    public:
        lion(){
            danger_level = 10;
        }
};

int main(){
    house_cat h;
    h.setName(&#x22;Fluffy&#x22;);
    
    lion l;
    l.setName(&#x22;Cecil&#x22;);
    
    cout &#x3C;&#x3C; h.getName() &#x3C;&#x3C; &#x22; is danger level: &#x22; &#x3C;&#x3C; h.getDanger_level() &#x3C;&#x3C; endl;
    cout &#x3C;&#x3C; l.getName() &#x3C;&#x3C; &#x22; is danger level: &#x22; &#x3C;&#x3C; l.getDanger_level() &#x3C;&#x3C; endl;
</code></pre>
This program outputs:
<pre><code>
Fluffy is danger level: 1
Cecil is danger level: 10
</code></pre>

<h2 id="async_future_promise">Async, Future, and Promise</h2>
<h3>Description</h3>
Future and promoise are two seperate sides of an asynchronous operation Promise acts as a producer and future acts as a consumer. A future will block until it's thread is ready to be joined. The function async creates a new thread and returns a future. The future function has two launch policies: 
<li>"std::launch::async" which cretes a new thread</li>
<li>"std::launch::deferred" which does not create a new thread</li>
By default async decides which launch policy works best at time of execution.
<h3>Example</h3>
<pre><code>#include &#x3C;iostream&#x3E;
#include &#x3C;future&#x3E;
#include &#x3C;vector&#x3E;

using namespace std;

int factorial(int input){
    int output = 1;
    for(uint i=1;i&#x3C;=input;i++){
        output *= i;
    }
    return output;
}

int main() {
    
    vector&#x3C;future&#x3C;int&#x3E; &#x3E; f;
    
    for(int i=1;i&#x3C;11;i++){
        f.push_back(async(factorial,i));
    }
    
    for(int i=1;i&#x3C;11;i++){
        cout &#x3C;&#x3C; i &#x3C;&#x3C; &#x22;! = &#x22; &#x3C;&#x3C; f[i-1].get() &#x3C;&#x3C; endl;
    }
}
</code></pre>
This program outputs:
<pre><code>1! = 1                                                                
2! = 2                                                                
3! = 6                                                                
4! = 24                                                               
5! = 120                                                              
6! = 720                                                              
7! = 5040                                                             
8! = 40320                                                            
9! = 362880                                                           
10! = 3628800 
</code></pre>

<h2 id="atomic_datatypes">Atomic Datatypes</h2>
<h3>Description</h3>
Atomic datatypes are datatypes that have all of their member functions execute as a single transaction. They are similar to mutexes, except they are signifigantly faster due to cache level optimization. Atomic datatypes do not inherit all of the member functions of their parent datatype. For example, in most cases, mulitply is not overloaded. Overloaded operators are good for making atomic datatypes readable, but in practice the atomic member functions help you write more "correct" code. Atomic member functions include: load(), store(), exchance(), etc.
<h3>Example</h3>
<pre><code>#include &lt;iostream&gt;
#include &lt;thread&gt;
#include &lt;atomic&gt;

using namespace std;

atomic&lt;int&gt; atomic_iter;
int iter = 0;

void update(){
    atomic_iter++;
    iter++;
}

int main()
{
    const auto processor_count = 10;

  thread threads[processor_count];

  for(uint i=0;i&lt;processor_count;i++){
    threads[i] = thread(update);
  }

  for(uint i=0;i&lt;processor_count;i++){
    threads[i].join();
  }
  
  cout &lt;&lt; atomic_iter &lt;&lt; endl; //Cannot have a race condition
  cout &lt;&lt; iter &lt;&lt; endl; //Can have a race condition

    return 0;
}
</code></pre>
This program outputs:
<pre><code>10
10
</code></pre>

<h2 id="auto">Auto</h2>
<h3>Description</h3>
Auto deduces the type of a declared variable from its initialization expression at compile time. There 
are situations where auto can make code for engineers much more difficult to read.
<h3>Example</h3>
<pre><code>#include &#x3C;iostream&#x3E;

using namespace std;

class point{
    
    public:
        int x,y;
    
        point(int x, int y){
            this-&#x3E;x = x;
            this-&#x3E;y = y;
        }
};

int main(){
    auto p = point(1,5); //Deduces the type from the initializer
    cout &#x3C;&#x3C; p.x &#x3C;&#x3C; &#x22;, &#x22; &#x3C;&#x3C; p.y &#x3C;&#x3C; endl;

    return 0;
}</code></pre>
This program outputs:
<pre><code>1, 5
</code></pre>

<h2 id="condition_variable">Condition Variables</h2>
<h3>Description</h3>
Condition variables allow a thread to atomically release a held mutex
and put itself to sleep. There are two main functions to a condition variable: wait() and
notify_one(). Wait() tells the thread to go to sleep until a notification is available.
Notify_one() sends a signal to one of the sleeping threads to wake up.

There are additional functions. Wait_for and wait_until allows us to cancel a thread's
sleeping to prevent a deadlock. Wait also has an option to take in a predicate to handle
sperious wakeups. We also have notify_all() which works like notify_one(), except it 
notifies all waiting threads instead of just one.
<h3>Example</h3>
<pre><code>#include &lt;iostream&gt;
#include &lt;condition_variable&gt;
#include &lt;thread&gt;
#include &lt;mutex&gt;
#include &lt;string&gt;
#include &lt;queue&gt;
#include &lt;chrono&gt;

using namespace std;

mutex m;
condition_variable cv;

queue&lt;string&gt; food_counter;


int main()
{
    
    for(uint i=0;i&lt;5;i++){
        thread customer([]{
            unique_lock&lt;mutex&gt; ul(m);
            cv.wait(ul);
            food_counter.pop();
            cout &lt;&lt; &quot;A customer ate the food&quot; &lt;&lt; endl;
        });
        customer.detach();
    }
    
    thread chef([]{
        for(uint i=0;i&lt;10;i++){
            unique_lock&lt;mutex&gt; ul(m);
            cout &lt;&lt; &quot;chef made food&quot; &lt;&lt; endl;
            food_counter.push(&quot;food&quot;);
            ul.unlock();
            cv.notify_one();
            std::this_thread::sleep_for(chrono::seconds(1));
        }
    });
    
    
    chef.join();
    
    return 0;
}
</code></pre>
This program outputs:
<pre><code>chef made food
A customer ate the food
chef made food
A customer ate the food
chef made food
A customer ate the food
chef made food
A customer ate the food
chef made food
A customer ate the food
chef made food
chef made food
chef made food
chef made food
chef made food
</code></pre>

<h2 id="const">Const</h2>
<h3>Description</h3>
A keyword that specifies that a variable's value is constant and prevents the programmer from modifying it. To make things more complicated, there are also pointers to consts and const pointers. Pointers to const can have thier address change, but not their value. Const pointers can have their values changed, but not their addresses.
<h3>Example</h3>
<pre><code>int main(){
    int a = 1;
    int b = 2;
    
    //Standard const
    const int test1 = a;
    //test1 = b; //Not allowed
    
    //Pointer to const
    const int* test2 = &amp;a;
    test2 = &amp;b; //Allowed
    //*test2 = b; //Not allowed
    
    //Pointer to const
    int* const test3 = &amp;a;
    *test3 = b; //Allowed
    //test3 = &amp;b; //Not allowed    
}
</pre></code>

<h2 id="context_switching">Context Switching</h2>
<h3>Description</h3>
Context switching is the process of storing the state of a process or a thread so that it can be later restored and resume execution at a later point. The act of "switching" from one process/ thread "context" takes time. This switching latency is caused by a number of low level effects. For example, task schedulers, TLB flushes, and CPU cache sharing.<br><br>

The following two examples assume each part of the program takes exactly 1 execution:<br>

<h2>Unoptimized for Context Switching</h2>
<style type="text/css">
    table.tableizer-table {
        font-size: 12px;
        border: 1px solid #CCC; 
        font-family: Arial, Helvetica, sans-serif;
    } 
    .tableizer-table td {
        padding: 4px;
        margin: 3px;
        border: 1px solid #CCC;
    }
    .tableizer-table th {
        background-color: #104E8B; 
        color: #FFF;
        font-weight: bold;
    }
</style>
<table class="tableizer-table">
<thead><tr class="tableizer-firstrow"><th># OF EXECUTIONS</th><th>THREAD 1</th><th>CONTEXT SWITCHING</th><th>THREAD 2</th></tr></thead><tbody>
 <tr><td>0</td><td>Lock m1</td><td>&nbsp;</td><td>&nbsp;</td></tr>
 <tr><td>1</td><td>Lock m2</td><td>&nbsp;</td><td>&nbsp;</td></tr>
 <tr><td>2</td><td>Do task</td><td>&nbsp;</td><td>&nbsp;</td></tr>
 <tr><td>3</td><td>Unlock m1</td><td>&nbsp;</td><td>&nbsp;</td></tr>
 <tr><td>4</td><td>&nbsp;</td><td>Switch -></td><td>&nbsp;</td></tr>
 <tr><td>5</td><td>&nbsp;</td><td>&nbsp;</td><td>Lock m1</td></tr>
 <tr><td>6</td><td>&nbsp;</td><td><- Switch</td><td>&nbsp;</td></tr>
 <tr><td>7</td><td>Unlock m2</td><td>&nbsp;</td><td>&nbsp;</td></tr>
 <tr><td>8</td><td>&nbsp;</td><td>&nbsp;</td><td>Lock m2</td></tr>
 <tr><td>9</td><td>&nbsp;</td><td>&nbsp;</td><td>Do task</td></tr>
 <tr><td>10</td><td>&nbsp;</td><td>&nbsp;</td><td>Unlock m1</td></tr>
 <tr><td>11</td><td>&nbsp;</td><td>&nbsp;</td><td>Unlock m2</td></tr>
</tbody></table>

<h2>Optimized for Context Switching</h2>
<style type="text/css">
    table.tableizer-table {
        font-size: 12px;
        border: 1px solid #CCC; 
        font-family: Arial, Helvetica, sans-serif;
    } 
    .tableizer-table td {
        padding: 4px;
        margin: 3px;
        border: 1px solid #CCC;
    }
    .tableizer-table th {
        background-color: #104E8B; 
        color: #FFF;
        font-weight: bold;
    }
</style>
<table class="tableizer-table">
<thead><tr class="tableizer-firstrow"><th># OF EXECUTIONS</th><th>THREAD 1</th><th>CONTEXT SWITCHING</th><th>THREAD 2</th></tr></thead><tbody>
 <tr><td>0</td><td>Lock m1</td><td>&nbsp;</td><td>&nbsp;</td></tr>
 <tr><td>1</td><td>Lock m2</td><td>&nbsp;</td><td>&nbsp;</td></tr>
 <tr><td>2</td><td>Do task</td><td>&nbsp;</td><td>&nbsp;</td></tr>
 <tr><td>3</td><td>Unlock m2</td><td>&nbsp;</td><td>&nbsp;</td></tr>
 <tr><td>4</td><td>Unlock m1</td><td>&nbsp;</td><td>&nbsp;</td></tr>
 <tr><td>5</td><td>&nbsp;</td><td>Switch -></td><td>&nbsp;</td></tr>
 <tr><td>6</td><td>&nbsp;</td><td>&nbsp;</td><td>Lock m1</td></tr>
 <tr><td>7</td><td>&nbsp;</td><td>&nbsp;</td><td>Lock m2</td></tr>
 <tr><td>8</td><td>&nbsp;</td><td>&nbsp;</td><td>Do task</td></tr>
 <tr><td>9</td><td>&nbsp;</td><td>&nbsp;</td><td>Unlock m1</td></tr>
 <tr><td>10</td><td>&nbsp;</td><td>&nbsp;</td><td>Unlock m2</td></tr>
</tbody></table>

<h3>Example</h3>
<pre><code>#include &lt;stdlib.h&gt;
#include &lt;thread&gt;
#include &lt;mutex&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;chrono&gt;

using namespace std;

mutex m0,m1;

int main(){
    
    auto t1 = std::chrono::high_resolution_clock::now();
    
    vector&lt;thread&gt; lots_of_context_switches;

    for(int i=0;i&lt;20000;i++){
        
        int product = 1;
        
        lots_of_context_switches.push_back(thread ([i,&amp;product]{
            m0.lock();
            m1.lock();
            
            product *= i;
            
            m0.unlock(); //Unlocking m0 first here causes more context switching
            m1.unlock(); 
        }));
    }
        
    for(auto &amp;v : lots_of_context_switches){
        v.join();
    }
    
    auto t2 = std::chrono::high_resolution_clock::now();
    std::cout &lt;&lt; &quot;lots_of_context_switches took &quot;
              &lt;&lt; std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(t2-t1).count()
              &lt;&lt; &quot; millisecondsn&quot;;
              
    auto t3 = std::chrono::high_resolution_clock::now();
 
    vector&lt;thread&gt; less_context_switches;

    for(int j=0;j&lt;20000;j++){
        
        int product = 1;
        
        less_context_switches.push_back(thread ([j,&amp;product]{
            m0.lock();
            m1.lock();
            
            product *= j;
            
            m1.unlock(); //Unlocking m1 first here causes less switching
            m0.unlock();
            
        }));
    }
        
    for(auto &amp;v : less_context_switches){
        v.join();
    }
    
    auto t4 = std::chrono::high_resolution_clock::now();
    std::cout &lt;&lt; &quot;less_context_switches took &quot;
              &lt;&lt; std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(t4-t3).count()
              &lt;&lt; &quot; millisecondsn&quot;;
}
</code></pre>
This program outputs:
<pre><code>lots_of_context_switches took 1861 milliseconds
less_context_switches took 1785 milliseconds
</code></pre>

<h2 id="deadlocks">Deadlocks</h2>
<h3>Description</h3>
A deadlock is any situation in which two or more threads are blocked indefinitely. For example, lets say there are two threads, t1 and t2, and two resources, r1 and r2. 
T1 and t2 both will not finish their execution unless they have both resource r1 and r2 locked. If t1 locks r1 and t2 locks r2, then neither thread will ever finish resulting in a
deadlock.
<h3>Example</h3>
<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;thread&gt;
#include &lt;mutex&gt;
#include &lt;unistd.h&gt;

using namespace std;

mutex chopstick1;
mutex chopstick2;

void eat1(){
    
    lock_guard&lt;mutex&gt; g1(chopstick1);
    usleep(1 * 1000000);
    lock_guard&lt;mutex&gt; g2(chopstick2);
    
    cout &lt;&lt; &quot;burp&quot; &lt;&lt; endl;
}

void eat2(){
    
    lock_guard&lt;mutex&gt; g2(chopstick2);
    usleep(1 * 1000000);
    lock_guard&lt;mutex&gt; g1(chopstick1);
    
    cout &lt;&lt; &quot;burp&quot; &lt;&lt; endl;
}


int main(){
    thread t1 = thread(eat1);
    thread t2 = thread(eat2);
    t1.join();
    t2.join();
}
</code></pre>

<h2 id="threads_vs_processes">Difference between a thread and a process</h2>
<h3>Description</h3>
A thread is a sequence of instructions executed concurrently and is part of a process. A process is an instance of a program. Threads are "lighter" than processes. They require less time for context switching and require less resources. Threads share resources, unlike processes. Processes collabrate less with each other compared to threads.
<h3>Example</h3>
<pre><code>#include &lt;iostream&gt;
#include &lt;thread&gt;
#include &lt;unistd.h&gt; 

using namespace std;

const uint NUM_THREADS = 3;
pid_t* pid = (pid_t*)malloc(sizeof(pid_t));

void task1(int id){
  printf(&quot;Process #%d, Thread #%dn&quot;,*pid,id);
}

int main(){

  //fork() creates a new process
  pid[0] = fork(); 

  thread threads[NUM_THREADS];

  for(int i=0;i&lt;NUM_THREADS;i++){
    //thread() creates a new thread
    threads[i] = thread(task1, i); 
  }

  for(int i=0;i&lt;NUM_THREADS;i++){
    threads[i].join();
  }
}
</code></pre>
This program outputs:
<pre><code>Process #0, Thread #0
Process #0, Thread #1
Process #1136, Thread #0
Process #1136, Thread #2
Process #0, Thread #2
Process #1136, Thread #1
</code></pre>

<h2 id="encapsulation">Encapsulation</h2>
<h3>Description</h3>
Encapsulation is the binding of data with the functions which manipulate them. Encapsulation
reduces complexity, protects our data, and makes our classes easier to change. Through data hiding,
encapsulation leads to more abstraction.
<h3>Example</h3>
<pre><code>#include &#x3C;iostream&#x3E;
#include &#x3C;string&#x3E;

using namespace std;

class product{
  double price;
  string name;
  
  public:
    double getPrice(){
      return price;  
    };
    
    string getName(){
      return name;  
    };
    
    void setPrice(double p){
        price = p;
    }
    
    void setName(string n){
        name = n;
    }
};

int main()
{
    product p;
    p.setPrice(19.99);
    p.setName(&#x22;Overpriced Hamburger&#x22;);
    
    cout &#x3C;&#x3C; &#x22;The &#x22; &#x3C;&#x3C; p.getName() &#x3C;&#x3C; &#x22; is $&#x22; &#x3C;&#x3C; p.getPrice();

    return 0;
}
</code></pre>
This progam outputs:
<pre><code>The Overpriced Hamburger is $19.99
</code></pre>

<h2 id="dependency_injection">Dependency Injection</h2>
<h3>Description</h3>
Dependency injection is providing the service objects that a client object needs instead of having the client object define the service objects themselves. Dependency injection can make testing and configuration easier, but can lead to less readable code.
<h3>Example</h3>
<pre><code>#include &#x3C;iostream&#x3E;

using namespace std;

class service{
};

class client{
    
    service myService;
    
    public:
        client(service s){
        }
};

int main()
{
    service s;
    client c(s);
    return 0;
}
</code></pre>

<h2 id="detached_threads">Detached Threads</h2>
<h3>Description</h3>
Detached threads are threads that have had their "detached()" member function called. They cannot be joined. When a detached thread is done, its resources are destroyed safely.
<h3>Example</h3>
<pre><code>#include &lt;iostream&gt;
#include &lt;thread&gt;
#include &lt;unistd.h&gt;

using namespace std;

int main ()
{
  thread t1([]{
     cout &lt;&lt; &quot;t1 started&quot; &lt;&lt; endl;
     sleep(3);
     cout &lt;&lt; &quot;t1 done&quot; &lt;&lt; endl;
  });
  
  thread t2([]{
     cout &lt;&lt; &quot;t2 started&quot; &lt;&lt; endl;
     sleep(2);
     cout &lt;&lt; &quot;t2 done&quot; &lt;&lt; endl;
  });
  
  thread t3([]{
     cout &lt;&lt; &quot;t3 started&quot; &lt;&lt; endl;
     sleep(1);
     cout &lt;&lt; &quot;t3 done&quot; &lt;&lt; endl;
  });
  
  t1.detach();
  t2.detach();
  t3.detach();
  
  sleep(5);

  return 0;
}
</code></pre>
This program outputs:
<pre><code>t1 started
t3 started
t2 started
t3 done
t2 done
t1 done
</code></pre>

<h2 id="diamond_problem">Diamond Probelem of Inheritance</h2>
<h3>Description</h3>
The diamond problem of inheritance is an issue where multiple inheritance can lead to ambigious data. The diamond problem is the following:
<li>We have four classes: A, B, C, and D</li>
<li>A has an uninitialized public member e</li>
<li>B and C publicaly inherit A and initialize e</li>
<li>D publicaly inherits B and C</li>
<li>What is the value of e when you initialize D?</li>
<h3>Example</h3>
<code><pre>#include &#x3C;iostream&#x3E;
#include &#x3C;string&#x3E;

using namespace std;

class animal{   
    
    public:
        virtual string says(){
            return &#x22;generic sound&#x22;;
        }
        
        animal(){
            cout &#x3C;&#x3C; &#x22;animal init&#x22; &#x3C;&#x3C; endl;
        }
        
        double height, width;
};

//virtual here allows for says() function to not be ambigious
class duck : virtual public animal {
    public:
        string says(){
            return &#x22;quack&#x22;;
        }
        
        duck(){
            cout &#x3C;&#x3C; &#x22;duck init&#x22; &#x3C;&#x3C; endl;
        }
};

//virtual here allows for says() function to not be ambigious
class mammal : virtual public animal{
    public:
        string says(){
            return &#x22;generic mammal sound&#x22;;
        }
        
        mammal(){
            cout &#x3C;&#x3C; &#x22;mammal init&#x22; &#x3C;&#x3C; endl;
        }
};

class platypus: public duck,mammal{
    public:
    string says(){
        return &#x22;platypus sound&#x22;;
    }
    
    platypus(){
        cout &#x3C;&#x3C; &#x22;platypus init&#x22; &#x3C;&#x3C; endl;
    }
};


int main()
{
    animal *a = new platypus();
    cout &#x3C;&#x3C; a-&#x3E;says() &#x3C;&#x3C; endl;
    
    return 0;
}
</code></pre>
This program outputs:
<pre><code>animal init
duck init
mammal init
platypus init
platypus sound
</code></pre>


<h2 id="enumerations">Enumerations</h2>
<h3>Description</h3>
A user defined set of named constants. It is a way of associating names with integers.
<h3>Example</h3>
<pre><code>#include &lt;iostream&gt;

enum temperature {cold, lukewarm, hot};
enum direction {East=0, West=180, North=90, South=270};

int main() {
  temperature temp1 = cold;
  temperature temp2 = hot;

  direction direction1 = East;
  direction direction2 = South;

  std::cout &lt;&lt; temp1 &lt;&lt; std::endl;
  std::cout &lt;&lt; temp2 &lt;&lt; std::endl;
  std::cout &lt;&lt; direction1 &lt;&lt; std::endl;
  std::cout &lt;&lt; direction2 &lt;&lt; std::endl;
}
</code></pre>
This program outputs:
<pre><code>0
2
0
270
</code></pre>

<h2 id="factory_method">Factory Method</h2>
<h3>Description</h3>
A factory method is a design pattern that lets you create a derived class at run time. A factory method returns a pointer to a virtual class. The virtual class is initalized as a derived class. Factory methods are needed with C++, becuase virtual constructors are not supported.
<h3>Example</h3>
<pre><code>#include &#x3C;iostream&#x3E;
#include &#x3C;memory&#x3E;
using namespace std;

class machine_ops{
    public:
        static machine_ops *make_instance(bool isLinux);
        virtual void power_off() = 0;
        virtual void reset() = 0;
};

class linux : public machine_ops{
    public:
        void power_off(){
            cout &#x3C;&#x3C; &#x22;Powering off Linux style&#x22; &#x3C;&#x3C; endl;
        }
        
        void reset(){
            cout &#x3C;&#x3C; &#x22;Resetting Linux style&#x22; &#x3C;&#x3C; endl;
        }
};

class windows : public machine_ops{
    public:
        void power_off(){
            cout &#x3C;&#x3C; &#x22;Powering off Windows style&#x22; &#x3C;&#x3C; endl;
        }
        
        void reset(){
            cout &#x3C;&#x3C; &#x22;Resetting Windows style&#x22; &#x3C;&#x3C; endl;
        }
};

machine_ops* machine_ops::make_instance(bool is_linux){
    if(is_linux){
        return new linux();
    }else{
        return new windows();
    }
}

int main() {
&#x9;
&#x9;machine_ops* m = machine_ops::make_instance(1);
&#x9;m-&#x3E;power_off();
&#x9;m-&#x3E;reset();
&#x9;
&#x9;return 0;
}
</code></pre>
This program outputs:
<pre><code>Powering off Linux style
Resetting Linux style
</code></pre>

<h2 id="final">Final</h2>
<h3>Description</h3>
Final is a keyword which prevents virtual functions from being overriden.
<h3>Example</h3>
<pre><code>#include &#x3C;iostream&#x3E;
#include &#x3C;vector&#x3E;

using namespace std;

class fish{
    public:
        virtual void print_home() final{
            cout &#x3C;&#x3C; &#x22;Ocean&#x22; &#x3C;&#x3C; endl;
        };
        void print_shape(){
            cout &#x3C;&#x3C; &#x22;Long&#x22; &#x3C;&#x3C; endl;
        };
};

class flounder : public fish{
    
    public:
        //Not allowed, would return error
        // void print_home(){
        //     cout &#x3C;&#x3C; &#x22;Sand&#x22; &#x3C;&#x3C; endl;
        // };
        
        void print_shape(){
            cout &#x3C;&#x3C; &#x22;Flat&#x22; &#x3C;&#x3C; endl;
        }
    
};

int main(){
    fish f1;
    f1.print_home();
    f1.print_shape();
    
    flounder f2;
    f2.print_home();
    f2.print_shape();
    
    return 0;
}
</code></pre>
This program outputs:
<pre><code>
Ocean
Long
Ocean
Flat
</code></pre>

<h2 id="friend_class">Friend Class</h2>
<h3>Description</h3>
A friend class in C++ can access the private and protected members of the class in which it was declared as a friend. A derived class cannot give itself access to it's parent class's private. Proper use of friend classes increases encapsulation.
<h3>Example</h3>
<pre><code>#include &#x3C;iostream&#x3E;
#include &#x3C;vector&#x3E;

using namespace std;

class flower;

class petal{
    string color;
    friend flower;
    
    public:
        string getColor(){
            return color;
        }
};

class flower{
    public:
        vector&#x3C;petal&#x3E; ps;
        void set_color(string c){
            for(auto &#x26;v : ps){
                v.color = c;
            }
        }
        
};

int main()
{
    flower f;
    f.ps.push_back(petal());
    f.ps.push_back(petal());
    f.ps.push_back(petal());
    f.set_color(&#x22;periwinkle&#x22;);
    for(auto &#x26;v : f.ps){
        cout &#x3C;&#x3C; v.getColor() &#x3C;&#x3C; endl;
    }
   
    return 0;
}
</code></pre>
This program outputs:
<pre><code>periwinkle
periwinkle
periwinkle
</code></pre>

<h2 id="friend_function">Friend Function</h2>
<h3>Description</h3>
A function that is given access to private and protected data. They are defined outside of the class scope.
<h3>Example</h3>
<pre><code>#include &#x3C;iostream&#x3E;
#include &#x3C;vector&#x3E;

using namespace std;

class grass{
    double length;
    
    friend void cut(grass &#x26;g);
    
    public:
        double getLength(){
            return length;
        };
    
        grass(double l){
            length = l;
        }

};

void cut(grass &#x26;g){
    g.length = 3;
}

int main()
{
    grass g1(5);
    grass g2(3);
    grass g3(6);
    
    cout &#x3C;&#x3C; &#x22;Before cut&#x22; &#x3C;&#x3C; endl;
    cout &#x3C;&#x3C; g1.getLength() &#x3C;&#x3C; endl;
    cout &#x3C;&#x3C; g2.getLength() &#x3C;&#x3C; endl;
    cout &#x3C;&#x3C; g3.getLength() &#x3C;&#x3C; endl;
    
    cut(g1);
    cut(g2);
    cut(g3);

    cout &#x3C;&#x3C; endl &#x3C;&#x3C; &#x22;After cut&#x22; &#x3C;&#x3C; endl;    
    cout &#x3C;&#x3C; g1.getLength() &#x3C;&#x3C; endl;
    cout &#x3C;&#x3C; g2.getLength() &#x3C;&#x3C; endl;
    cout &#x3C;&#x3C; g3.getLength() &#x3C;&#x3C; endl;
    
    return 0;
}
</code></pre>
This program outputs:
<pre><code>
Before cut
5
3
6

After cut
3
3
3
</code></pre>

<h2 id="inline">Inline Functions</h2>
<h3>Description</h3>
Forces the compilier to directly replace function calls with the contents of the function. This allows faster runtimes for functions that are small and called often.
<h3>Example</h3>
<pre><code>#include &lt;iostream&gt;
#include &lt;chrono&gt;
#include &lt;thread&gt;
#include &lt;iostream&gt;
#include &lt;float.h&gt;

using namespace std;

double small_increase(double a){
    return a*1.00001;
}    

inline double inline_small_increase(double a){
    return a*1.00001;
}    

int main(){
    
    double x = 2;
    double y = 2;
    
    auto t1 = chrono::high_resolution_clock::now();
    while(x &lt; DBL_MAX){
        x = small_increase(x);
    }
    auto t2 = chrono::high_resolution_clock::now();
    while(y &lt; DBL_MAX){
        y = inline_small_increase(x);
    }
    auto t3 = chrono::high_resolution_clock::now();
    
    cout &lt;&lt; &quot;non-inline took &quot;
              &lt;&lt; chrono::duration_cast&lt;std::chrono::milliseconds&gt;(t2-t1).count()
              &lt;&lt; &quot; milliseconds&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;inline took &quot;
              &lt;&lt; chrono::duration_cast&lt;std::chrono::milliseconds&gt;(t3-t2).count()
              &lt;&lt; &quot; milliseconds&quot; &lt;&lt; endl;
}
</code></pre>
This program outputs:
<pre><code>non-inline took 132 milliseconds
inline took 0 milliseconds
</code></pre>

<h2 id="interfaces">Interfaces</h2>
<h3>Description</h3>
<h3>Example</h3>
Interfaces are used to separate the declaration from the implementation. Implementation of an interface is done with run-time polymorphism. An abstract class that only has pure abstract classes is an interface. Pure virtual functions are virtual functions which end in "=0";
<code><pre>
<h3>Example</h3>#include &#x3C;iostream&#x3E;

using namespace std;

class person{
    public:
    virtual void speak() = 0;
    virtual int getSalary() = 0;
};

class teacher : person{
    public: 
    void speak(){
        cout &#x3C;&#x3C; &#x22;Today&#x27;s lesson is...&#x22; &#x3C;&#x3C; endl;
    }
    int getSalary(){
        return 50000;
    }
};

class student : person{
    public:
    void speak(){
        cout &#x3C;&#x3C; &#x22;I love learning&#x22; &#x3C;&#x3C; endl;
    }
    int getSalary(){
        return 0;
    }
};

int main ()
{
  teacher t;
  student s;
  t.speak();
  s.speak();

  return 0;
}
</code></pre>
This program outputs:
<pre><code>Today's lesson is...
I love learning
</code></pre>

<h2 id="inheritance">Inheritance</h2>
<h3>Description</h3>
Inheritance is when you define a class in terms of another class. It allows us to write less code. Less code equals less opportunities 
for bugs. Inheritance is a "is a" relationship. For example, a vehicle IS A car. There are three kinds of inheritance: public,
protected, and private. A derived class inherits all of the base class's methods except for: constructors, destructors, copy constructors, 
overloaded operators, and friend functions. 

When a derived class overrides a method from its parent, not only does the overriden function become hidden, but all of the overloaded methods of the parent become hidden too. These hidden parent methods can still be access using their scope resolution operator.
<h3>Example</h3>
<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;

using namespace std;

class edible{
    public:
    int calories;
};

class animal{
    public:
    int consumed_calories = 0;
    virtual void eat(edible e) = 0;
};

class tiger : public animal{
    public:
    void eat(edible e){
        consumed_calories += e.calories;
        cout &lt;&lt; &quot;The tiger has &quot; &lt;&lt; consumed_calories &lt;&lt; &quot; total calories&quot; &lt;&lt; endl;
    }
};

class rabbit : public edible, public animal{
    public:
    void eat(edible e){
        consumed_calories += e.calories;
        cout &lt;&lt; &quot;The rabbit has &quot; &lt;&lt; consumed_calories &lt;&lt; &quot; total calories&quot; &lt;&lt; endl;
    }
    
    rabbit(){
        calories = 5000;
    }
};

class grass : public edible{
    public:
    grass(){
        calories = 1;
    }
};

int main()
{
    tiger t1;
    rabbit r1;
    grass g1;
    grass g2;
    grass g3;
    
    r1.eat(g1);
    r1.eat(g1);
    r1.eat(g1);
    t1.eat(r1);

    return 0;
}
</code></pre>
This program outputs:
<pre><code>The rabbit has 1 total calories                                                                                                                                              
The rabbit has 2 total calories                                                                                                                                              
The rabbit has 3 total calories                                                                                                                                              
The tiger has 5000 total calories
</code></pre>

<h2 id="iterators">Iterators</h2>
<h3>Description</h3>
Any object that points to some element and has the ability to iterate through the 
elements with the operators "++"(increment) and "*"(dereference).
<h3>Example</h3>
<pre><code>#include &lt;iostream&gt;
#include &lt;iterator&gt;
#include &lt;vector&gt;
#include &lt;deque&gt;

//This function returns the mean of a iterable container
template &lt;class InputIterator, class T&gt; double mean(InputIterator first, InputIterator last, T init){

  T output = 0;
  double count = 0;

  while (first!=last) {
    output += *first;
    first++;
    count++;
  }
  return output/count;
}

int main() {
  std::vector&lt;int&gt; v = {1,2,3,4};
  std::deque&lt;double&gt; d = {5.1,5.2,5.3};
  std::cout &lt;&lt; mean(v.begin(),v.end(),0) &lt;&lt; std::endl;
  std::cout &lt;&lt; mean(d.begin(),d.end(),0.0) &lt;&lt; std::endl;
}
</code></pre>
This program outputs:
<pre><code>2.5
5.2
</code></pre>

<h2 id="lambda_functions">Lambda Functions</h2>
<h3>Description</h3>
A function written in line without an identifier. Functions without idenfifiers 
are called "anonymous functions". Anonymous functions can only be invoked once.
<h3>Example</h3>
<pre><code>#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

typedef struct rectangle{
  double width;
  double height;
} rectangle;

int main(){

    vector&lt;rectangle&gt; rects;
    rectangle r1 = {0,1};
    rects.push_back(r1);
    rectangle r2 = {3,3};
    rects.push_back(r2);
    rectangle r3 = {1,2};
    rects.push_back(r3);
    rectangle r4 = {4,4};
    rects.push_back(r4);
    rectangle r5 = {2,1};
    rects.push_back(r5);
    
    sort(rects.begin(), rects.end(), [](const rectangle&amp; a, const rectangle&amp; b) -&gt; bool{ 
        return a.width * a.height &lt; b.width * b.height; 
    }); 
    
    cout &lt;&lt; &quot;width, height&quot; &lt;&lt; endl;
    for(auto &amp;v:rects){
        cout &lt;&lt; v.width &lt;&lt; &quot;, &quot; &lt;&lt; v.height &lt;&lt; endl;
    }
    
    return 0;
}
</code></pre>
This program outputs:
<pre><code>width, height
0, 1
1, 2
2, 1
3, 3
4, 4
</code></pre>

<h2 id="mutexes">Mutexes</h2>
<h3>Description</h3>
Lockable objects that are designed to signal when critical sections of code require
exclusive access. They lock when they get to the critical section and unlock once they
are done with it.
<h3>Example</h3>
<pre><code>#include &lt;iostream&gt;
#include &lt;thread&gt;
#include &lt;mutex&gt;
#include &lt;unistd.h&gt;

const uint NUM_THREADS = 3;

using namespace std;

mutex m;

void hello_without_mutex(uint id) {
  cout &lt;&lt; &quot; Hello&quot;;
  usleep(1000);
  cout &lt;&lt; &quot; I am &quot;;
  cout &lt;&lt; id &lt;&lt; endl;
}

void hello_with_mutex (uint id) {
  lock_guard&lt;std::mutex&gt; g(m); 
  cout &lt;&lt; &quot; Hello&quot;;
  usleep(1000);
  cout &lt;&lt; &quot; I am &quot;;
  cout &lt;&lt; id &lt;&lt; endl;
}

int main() {

  cout &lt;&lt; &quot;Without Mutexes:&quot; &lt;&lt; endl;

   thread threads1[NUM_THREADS];
   for(uint i=0;i&lt;NUM_THREADS;i++){
     threads1[i] = thread(hello_without_mutex,i);
   }

   for(int i=0;i&lt;NUM_THREADS;i++){
     threads1[i].join();
   }
   
   cout &lt;&lt; endl;
   cout &lt;&lt; &quot;With Mutexes:&quot; &lt;&lt; endl;

   thread threads2[NUM_THREADS];
   for(uint i=0;i&lt;NUM_THREADS;i++){
     threads2[i] = thread(hello_with_mutex,i);
   }

   for(int i=0;i&lt;NUM_THREADS;i++){
     threads2[i].join();
   }
}
</code></pre>
This program outputs:
<pre><code>Without Mutexes:
 Hello Hello Hello I am 0
 I am 2
 I am 1

With Mutexes:
 Hello I am 0
 Hello I am 2
 Hello I am 1
</code></pre>

<h2 id="no_except">No Except</h2>
<h3>Description</h3>
Noexcept is a specifier which makes it so that a function is not allowed to throw an exception.
<h3>Example</h3>
<pre><code>#include &#x3C;iostream&#x3E;

using namespace std;

double the_number_two() noexcept {
    //throw 2; THIS WOULD CAUSE AN ERROR
    return 2;
}

int main(){
    the_number_two();
    return 0;
}
</code></pre>

<h2 id="once_flag">Call_once Flag</h2>
<h3>Description</h3>
The call once flag ensures that a callable is only called once. The "call_once()" function take a once_flag and callable function as parameters.
<h3>Example</h3>
<pre><code>#include &#x3C;iostream&#x3E;
#include &#x3C;mutex&#x3E;
#include &#x3C;time.h&#x3E;
#include &#x3C;chrono&#x3E;

using namespace std;

once_flag flag;
string x;

void get_time(){
    time_t     now = time(0);
    struct tm  tstruct;
    char       buf[80];
    tstruct = *localtime(&#x26;now);
    strftime(buf, sizeof(buf), &#x22;%Y-%m-%d.%X&#x22;, &#x26;tstruct);
    
    x = buf;
}

int main(){
    
    call_once(flag,get_time);
    cout &#x3C;&#x3C; x &#x3C;&#x3C; endl;
    call_once(flag,get_time);
    cout &#x3C;&#x3C; x &#x3C;&#x3C; endl;
    call_once(flag,get_time);
    cout &#x3C;&#x3C; x &#x3C;&#x3C; endl;
    
    return 0;
}
</code></pre>
This program outputs:
<pre><code>2020-12-13.22:18:36
2020-12-13.22:18:36
2020-12-13.22:18:36
</code></pre>

<h2 id="override_keyword">Override Keyword</h2>
<h3>Description</h3>
The override keyword shows the reader of the code that you are overriding a 
virtual function. When this keyword is used, the compiler will verify that your function is being overridden. Good C++ software engineers prefer compile time errors over runtime errors.
<h3>Example</h3>
<pre><code>#include &#x3C;iostream&#x3E;
#include &#x3C;vector&#x3E;

using namespace std;

class item{
    public:
        virtual double price() = 0;
};

class banana : public item{
    public:
        double price() override {
            return 1.00;
        }
};

int main()
{
    item* i = new banana();
    cout &#x3C;&#x3C; i-&#x3E;price() &#x3C;&#x3C; endl;
    
    return 0;
}
</code></pre>
This program outputs:
<pre><code>1
</code></pre>

<h2 id="pimpl">PIMPL Idiom</h2>
<h3>Description</h3>
The PIMPL idiom is when you move all private members of a class from its header file to its implementation file. This provides two benefits: less complilation time when change a class's private members and more data hiding which improves abstraction. PIMPL is useful if your library is confidential. The private members are moved to the implemenation file by:
<li>Forward declaring an "IMPL" class as a public member in the header</li>
<li>Declaring an unique pointer to the "IMPL" class</li>
<li>Defining the "IMPL" class as a struct in the implmentation file containg all of the private members</li>
<li>And finally initalizing the "IMPL" class in the main class's constructor</li>
<h3>Example</h3>
<pre><code>#include &#x3C;iostream&#x3E;
#include &#x3C;string&#x3E;
#include &#x3C;memory&#x3E;

using namespace std;

//HEADER FILE
class launch_nuclear_missle {
    private:
        class IMPL;
        unique_ptr&#x3C;IMPL&#x3E; impl_;
    public:
        launch_nuclear_missle();
};

//IMPLEMENTATION FILE
struct launch_nuclear_missle::IMPL{
    void call_president(); //We don&#x27;t want anyone seeing this
    void call_general(); //We don&#x27;t want anyone seeing this
};

launch_nuclear_missle::launch_nuclear_missle() : impl_(new IMPL){
    impl_-&#x3E;call_president();
    impl_-&#x3E;call_general();
}

void launch_nuclear_missle::IMPL::call_president(){
    cout &#x3C;&#x3C; &#x22;Calling Mr. President...&#x22; &#x3C;&#x3C; endl;
}

void launch_nuclear_missle::IMPL::call_general(){
    cout &#x3C;&#x3C; &#x22;Calling the general...&#x22; &#x3C;&#x3C; endl;
}

int main()
{
    launch_nuclear_missle();
    return 0;
}
</code></pre>
This program outputs:
<pre><code>Calling Mr. President...
Calling the general...
</code></pre>

<h2 id="predicate">Predicate</h2>
<h3>Description</h3>
Predicates are any callable function which returns a bool. Many STL algorithms use
predicates as an input. For example, all_of(), any_of(), and none_of().
<h3>Example</h3>
<pre><code>#include &#x3C;iostream&#x3E;
#include &#x3C;algorithm&#x3E;
#include &#x3C;vector&#x3E;

using namespace std;

//This is a predicate
bool is_positive(int i){
    if(i) return true;
    return false;
}

int main() {
    
    vector&#x3C;int&#x3E; nums = {0,1,-5,5,9,-9};
    
    cout &#x3C;&#x3C; all_of(nums.begin(),nums.end(),is_positive) &#x3C;&#x3C; endl;
    cout &#x3C;&#x3C; any_of(nums.begin(),nums.end(),is_positive) &#x3C;&#x3C; endl;
    cout &#x3C;&#x3C; none_of(nums.begin(),nums.end(),is_positive) &#x3C;&#x3C; endl;

    return 0;
}
</code></pre>
This program outputs:
<pre><code>0
1
0
</code></pre>

<h2 id="inherience_types">Public VS Protected VS Private Inherience</h2>
<h3>Description</h3>
Public inheritance has everything able to access everything of the base class. Protected inheritance only has the children able to access everything of the base class. Private inheritance only allows the parent to have access to everything. Default inheritance is private.
<h3>Example</h3>
<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;

using namespace std;

class public_child{
    public:
        string a = &quot;public childred&quot;; 
};

class protected_child{
    public:
        string b = &quot;protected childred&quot;; 
};

class private_child{
    public:
        string c = &quot;private childred&quot;; 
};

class A : public public_child, protected protected_child, private private_child{
    
    public:
        string get_b(){
            return b;
        }
        
        string get_c(){
            return c;
        }
        
};

class B : A {
    
    public:
        string get_a(){
                return b;
        }
        
        string get_b(){
                return b;
        }
};

int main()
{
  A test;
  cout &lt;&lt; test.a &lt;&lt; &quot; can access directly&quot; &lt;&lt; endl;
  cout &lt;&lt; test.get_b() &lt;&lt; &quot; and &quot; &lt;&lt; test.get_c() &lt;&lt; &quot; need getters&quot; &lt;&lt; endl;
  B test2;
  cout &lt;&lt; test2.get_a() &lt;&lt; &quot; and &quot; &lt;&lt; test2.get_b() 
  &lt;&lt; &quot; can be printed by children of the base class&quot; &lt;&lt; endl;
}
</code></pre>
This program outputs:
<pre><code>public childred can access directly
protected childred and private childred need getters
protected childred and protected childred can be printed by children of the base class
</code></pre>

<h2 id="race_conditions">Race Conditions</h2>
<h3>Description</h3>
A race condition is when two or more threads try to read or write a piece of data
and atleast one of those threads is writing. Race conditions result in undefined behavior. The 
cure for a race condition, most of the time, is mutexes.
<h3>Example</h3>
<pre><code>#include &lt;iostream&gt;
#include &lt;thread&gt;
#include &lt;unistd.h&gt;
#include &lt;stack&gt;

using namespace std;

std::stack&lt;int&gt; s;

void remove_add_1(){
    //MUTEX HERE WOULD PREVENT RACE CONDITION
    s.pop();
    usleep(1000);
    s.push(1);
    cout &lt;&lt; s.top() &lt;&lt; endl;
}

int main(){
    
    s.push(0);
    
    thread readers[10];
    
    for(int i=0;i&lt;10;i++){
        readers[i] = thread(remove_add_1);
    }
    
    for(int i=0;i&lt;10;i++){
        readers[i].join();
    }
}
</code></pre>
This program outputs:
<pre><code>Created
Segmentation Fault
</code></pre>

<h2 id="raii">RAII</h2>
<h3>Description</h3>
Stands for "Resource Acquistion Is Initialization". This is a terrible name for a 
great concept. A better name for RAII would be "Scope Based Memory Management". 
The resource allocation is done at initialization by the constructor and the resource 
deallocation is done at finalization by the destructor. 
<h3>Example</h3>
<pre><code>#include &lt;iostream&gt;
#include &lt;memory&gt;

class true_false_exam{
  public:
  bool* answers;

  true_false_exam(){
    answers = new bool(100); 
    std::cout &lt;&lt; &quot;Created&quot; &lt;&lt; std::endl;
  }

  ~true_false_exam(){
    delete (answers);
    std::cout &lt;&lt; &quot;Deleted&quot; &lt;&lt; std::endl;
  }
};

int main() {
  //Unique pointer will automatically call the deconstructor
  //once the object is out of scope
  std::unique_ptr&lt;true_false_exam&gt; t(new true_false_exam());
}
</code></pre>
This program outputs:
<pre><code>Created
Deleted
</code></pre>

reference_vs_pointer

<h2 id="reference_vs_pointer">Reference Vs. Pointer</h2>
<h3>Description</h3>
A pointer holds an address in memory. In order to access the data to this address, the programmer has to use the dereference operator "*". References are an alias of an existing variable. One can think of references as a constant pointer who's value can be changed, but its address cannot.
<h3>Example</h3>
<pre><code>#include &#x3C;iostream&#x3E;
using namespace std;

int main() {
&#x9;
&#x9;int* ptr = new int(0);
&#x9;int&#x26; ref = *ptr;
&#x9;
&#x9;cout &#x3C;&#x3C; &#x22;ptr address: &#x22; &#x3C;&#x3C; ptr &#x3C;&#x3C; endl;
&#x9;cout &#x3C;&#x3C; &#x22;ptr value: &#x22; &#x3C;&#x3C; *ptr &#x3C;&#x3C; endl;
&#x9;cout &#x3C;&#x3C; &#x22;ref value: &#x22; &#x3C;&#x3C; ref &#x3C;&#x3C; endl &#x3C;&#x3C; endl;
&#x9;ref++;
&#x9;cout &#x3C;&#x3C; &#x22;ptr address: &#x22; &#x3C;&#x3C; ptr &#x3C;&#x3C; endl;
&#x9;cout &#x3C;&#x3C; &#x22;ptr value: &#x22; &#x3C;&#x3C; *ptr &#x3C;&#x3C; endl;
&#x9;cout &#x3C;&#x3C; &#x22;ref value: &#x22; &#x3C;&#x3C; ref &#x3C;&#x3C; endl &#x3C;&#x3C; endl;
&#x9;ptr = new int(5);
&#x9;cout &#x3C;&#x3C; &#x22;ptr address: &#x22; &#x3C;&#x3C; ptr &#x3C;&#x3C; endl;
&#x9;cout &#x3C;&#x3C; &#x22;ptr value: &#x22; &#x3C;&#x3C; *ptr &#x3C;&#x3C; endl;
&#x9;cout &#x3C;&#x3C; &#x22;ref value: &#x22; &#x3C;&#x3C; ref &#x3C;&#x3C; endl;
&#x9;
&#x9;return 0;
}
</code></pre>
This program outputs:
<pre><code>ptr address: 0x10d2c20
ptr value: 0
ref value: 0

ptr address: 0x10d2c20
ptr value: 1
ref value: 1

ptr address: 0x10d3c50
ptr value: 5
ref value: 1
</code></pre>

<h2 id="scoped_lock">Scoped Lock</h2>
<h3>Description</h3>
A scoped lock locks an arbitrary number of mutexes and avoids deadlocks. If you use scoped lock with only one lock, it works 
very similar to lock_guard.
<h3>Example</h3>
<pre><code>#include &#x3C;iostream&#x3E;
#include &#x3C;mutex&#x3E;
#include &#x3C;thread&#x3E;
#include &#x3C;unistd.h&#x3E;

using namespace std;

int num_cheese = 10;
int num_bread = 20;
int num_sandwichs = 0;

mutex m1,m2,m3;

int main()
{
    for(int i=0;i&#x3C;10;i++){
        thread t([i]{
            scoped_lock s(m1,m2,m3);
            num_cheese -= 1;
            num_bread -= 2;
            num_sandwichs++;
            cout &#x3C;&#x3C; i &#x3C;&#x3C; &#x22; made their sandwich&#x22; &#x3C;&#x3C; endl;
            cout &#x3C;&#x3C; &#x22;num_sandwichs: &#x22; &#x3C;&#x3C; num_sandwichs &#x3C;&#x3C; endl;
            usleep(100);
        });
        
        t.detach();
    }
    
    sleep(1);
    
    
    return 0;
}
</code></pre>
This program outputs:
<pre><code>0 made their sandwich
num_sandwichs: 1
4 made their sandwich
num_sandwichs: 2
2 made their sandwich
num_sandwichs: 3
3 made their sandwich
num_sandwichs: 4
1 made their sandwich
num_sandwichs: 5
5 made their sandwich
num_sandwichs: 6
6 made their sandwich
num_sandwichs: 7
7 made their sandwich
num_sandwichs: 8
8 made their sandwich
num_sandwichs: 9
9 made their sandwich
num_sandwichs: 10
</code></pre>

<h2 id="semaphores">Semaphores</h2>
<h3>Description</h3>
Used to control access to a common resource. When you create a semaphore you give
it a starting resource count. Every time we use a resource we decrement from the resource
count. Every time we are done with the resource we increment. If the resource count is
less than zero, when we want the resource, then we must wait until the resource count is greater than 
or equal to zero. 
<br><br>
Semaphores which allow an arbitrary resource count are called "counting semaphores". 
Semaphores which are either locked or unlocked are called "binary semaphores". Binary semaphores
can be used as a mutex.
<h3>Example</h3>
<pre><code>#include &lt;iostream&gt;
#include &lt;pthread.h&gt;
#include &lt;vector&gt;
#include &lt;mutex&gt;

using namespace std;

const uint NUM_THREADS = 5;

class semaphore{
    
    private: 
        pthread_mutex_t lock;
        pthread_cond_t wait;
        int value;
        
        
    public: 
    
        semaphore(int v){
            value = v;
            pthread_cond_init(&amp;wait,NULL);
            pthread_mutex_init(&amp;lock,NULL);
        }
        
        void P(){
            value--;
            if(value &lt; 0) {
                pthread_cond_wait(&amp;wait,&amp;lock);
            }
            pthread_mutex_unlock(&amp;lock);
        }
        
        void V(){
            pthread_mutex_lock(&amp;lock);
            value++;
            if(value &lt;= 0) {
                pthread_cond_signal(&amp;wait);
            }
            pthread_mutex_unlock(&amp;lock);
        }

};

semaphore* s = new semaphore(2);

void *test_func(void *input) {
    
    int id = *((int*)(&amp;input));
    
    printf(&quot;%d is inn&quot;,id);
    s-&gt;P();
    
    for(int wasting_time=0;wasting_time&lt;1000000000*id;wasting_time++);

    s-&gt;V();
    printf(&quot;%d is outn&quot;,id);
    
    return NULL;
}

int main(){   
    pthread_t threads[NUM_THREADS];
    
    //Starting each thread
    for(uint i = 0; i &lt; NUM_THREADS; i++) {
        pthread_create(&amp;threads[i], NULL, test_func, (void*)i);
    }

    //Stopping and collecting data from each thread
    for(uint i = 0; i &lt; NUM_THREADS; i++) {
        pthread_join(threads[i], NULL);
    }
}
</code></pre>
This program outputs:
<pre><code> 0 is in
  0 is out
  2 is in
  4 is in
  4 is out
  2 is out
  1 is in
  1 is out
  3 is in
  3 is out
</code></pre>

<h2 id="shared_lock">Shared Lock</h2>
<h3>Description</h3>
Shared locks can be used in conjunction with unique locks to allow multiple readers and exclusive writers. They are similar to 
unique_locks in that they can be moved but not copied. Shared locks are used for read integrity.
<h3>Example</h3>
<pre><code>#include &#x3C;iostream&#x3E;
#include &#x3C;shared_mutex&#x3E;
#include &#x3C;mutex&#x3E;
#include &#x3C;thread&#x3E;
#include &#x3C;unistd.h&#x3E;

using namespace std;

double price = 0;
shared_timed_mutex m;
mutex pm;

void update_price(double p){
    unique_lock ul(m);
    price = p;
    lock_guard&#x3C;mutex&#x3E; lg(pm);
    cout &#x3C;&#x3C; &#x22;The new price is &#x22; &#x3C;&#x3C; price &#x3C;&#x3C; endl;
}

double read_price(){
    shared_lock sl(m);
    lock_guard&#x3C;mutex&#x3E; lg(pm);
    cout &#x3C;&#x3C; &#x22;Reading price: &#x22; &#x3C;&#x3C; price &#x3C;&#x3C; endl;
    return price;
}

int main(){
        
    for(uint i=0;i&#x3C;10;i++){
        
        usleep(100);
        
        thread t;
        
        if(i%3==0){
            t = thread(update_price,i);
        }
        else{
            t = thread(read_price);
        }
    
        t.detach();
        
    }
    
    sleep(1);
    
    
    return 0;
}
</code></pre>
This program outputs:
<pre><code>The new price is 0
Reading price: 0
Reading price: 0
The new price is 3
Reading price: 3
Reading price: 3
The new price is 6
Reading price: 6
Reading price: 6
The new price is 9
</code></pre>

<h2 id="slicing">Slicing</h2>
<h3>Description</h3>
Slicing is when you assign an object of a derived class to an instance of a base class, therefore some its information is "sliced" away.
<h3>Example</h3>
<pre><code>#include &#x3C;iostream&#x3E;
#include &#x3C;string&#x3E;

using namespace std;

class vehicle{
    public:
        string color = &#x22;red&#x22;;
};

class truck : public vehicle{
    public:
        double bed_size = 5;
};

int main()
{
    vehicle* v = new truck();
    cout &#x3C;&#x3C; v-&#x3E;color &#x3C;&#x3C; endl;
    //cout &#x3C;&#x3C; v-&#x3E;bed_size &#x3C;&#x3C; endl; This is sliced away
    
    return 0;
}
</code></pre>
This program outputs:
<pre><code>red
</code></pre>

<h2 id="smart_pointers">Smart Pointer</h2>
<h3>Description</h3>
Similar to a pointer except it has automatic memory management. Once the scope
of the smart pointer ends, the program knows to destory the pointer. There are currently
three kinds of smart pointers: "unique_ptr", "shared_ptr", and "weak_ptr". There used
to be an "auto_ptr", but this was deprecated in c++11 and removed in c++17.
  <h4 id="unique_pointers">Unique Pointers</h4>
  Owns and manages another object through a pointer and disposes of it when the
  pointer goes out of scope. If you try to make a copy of a unique pointer, the
  compilier will give you an error.
  <h4 id="shared_pointers">Shared Pointers</h4>
  Same thing as a unique pointer, except you are allowed to make copies.
  <h4 id="weak_pointers">Weak Pointers</h4>
  Smart pointer that has a non-owning("weak") reference to an object that is a
  shared pointer.
<h3>Example</h3>
<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;memory&gt;

class named_object{

  public:

    std::string name;

    named_object(std::string n){
      name = n;
      std::cout &lt;&lt; name &lt;&lt; &quot; created&quot; &lt;&lt; std::endl;
    }

    ~named_object(){
      std::cout &lt;&lt; name &lt;&lt; &quot; deleted&quot; &lt;&lt; std::endl;
    }
};

int main() {
  //The raw pointer is not deleted correctly because it is not "smart"
  named_object* raw = new named_object(&quot;raw pointer&quot;); 

  //The unique, shared, and weak pointers below are deleted correctly
  //because they are "smart"
  std::unique_ptr&lt;named_object&gt; unique(new named_object(&quot;unique&quot;));
  std::shared_ptr&lt;named_object&gt; shared(new named_object(&quot;shared&quot;));
  std::shared_ptr&lt;named_object&gt; shared2 = shared;
  std::weak_ptr&lt;named_object&gt; weak = shared2;
}
</code></pre>
This program outputs:
<pre><code>raw pointer created
unique created
shared created
shared deleted
unique deleted
</code></pre>

static_vs_dynamic_memory

<h2 id="static_vs_dynamic_memory">Static vs Dynamic memory</h2>
<h3>Description</h3>
Static memory lives on heap and dynamic memory lives on the stack. As static memory is allocated, the heap travels down and as dynamic memory is allocated the stack travels up. If the heap and the stack meet each other in the middle, you are out of memory!

Static memory is managed by the compiler and dynamic memory is managed by the programmer. In order to create static data the programmer can use common initialization, for example "int i = 5;". If the programmer wants to create dynamic data, they use "new" or "malloc". "new" or "malloc" allocates memory on the stack and returns the address of the allocated memory. This address is stored in a "pointer". If the program attempts to allocate memory when there is not enough, new would throw a "bad_alloc" and malloc would return a nullptr. If the programmer does not free the dynamically allocated memory, a data leak occurs. 

<h2 id="stl_algorithms">STL Algorithms</h2>
<h3>Description</h3>
The STL algorithms are a large number of helpful algorithms each implemented with iterator. Some of the algorithms require
an operator to declared, for example "<". STL algorithms are helpful for writing fast programs quickly.
<h3>Example</h3>
<pre><code>#include &#x3C;iostream&#x3E;
#include &#x3C;vector&#x3E;
#include &#x3C;algorithm&#x3E;
#include &#x3C;chrono&#x3E;
#include &#x3C;random&#x3E;

using namespace std;

int main()
{
    vector&#x3C;char&#x3E; kemps_deck;
    for(int i=0;i&#x3C;4;i++){
        for(int j=0;j&#x3C;9;j++){
            kemps_deck.push_back(48+j);
        }
        kemps_deck.push_back(&#x27;J&#x27;);
        kemps_deck.push_back(&#x27;Q&#x27;);
        kemps_deck.push_back(&#x27;K&#x27;);
        kemps_deck.push_back(&#x27;A&#x27;);
    }
    
    unsigned seed = std::chrono::system_clock::now().time_since_epoch().count();
    shuffle(kemps_deck.begin(),kemps_deck.end(),default_random_engine(seed)); //from &#x3C;algorithm&#x3E;
    
    vector&#x3C;char&#x3E; player1_hand;
    vector&#x3C;char&#x3E; player2_hand;
    vector&#x3C;char&#x3E; player3_hand;
    vector&#x3C;char&#x3E; player4_hand;
    
    for(int i=0;i&#x3C;4;i++){
        player1_hand.push_back(kemps_deck.back());
        kemps_deck.pop_back();
        player2_hand.push_back(kemps_deck.back());
        kemps_deck.pop_back();
        player3_hand.push_back(kemps_deck.back());
        kemps_deck.pop_back();
        player4_hand.push_back(kemps_deck.back());
        kemps_deck.pop_back();
    }
    
    sort(player1_hand.begin(),player1_hand.end()); //from &#x3C;algorithm&#x3E;
    sort(player1_hand.begin(),player1_hand.end()); //from &#x3C;algorithm&#x3E;
    sort(player1_hand.begin(),player1_hand.end()); //from &#x3C;algorithm&#x3E;
    sort(player1_hand.begin(),player1_hand.end()); //from &#x3C;algorithm&#x3E;

    cout &#x3C;&#x3C; &#x22;Player 1&#x27;s Hand: &#x22; &#x3C;&#x3C; endl;
    for(int i=0;i&#x3C;4;i++){
        cout &#x3C;&#x3C; &#x22;   &#x22; &#x3C;&#x3C; player1_hand[i] &#x3C;&#x3C; endl;
    }
    if(equal(player1_hand.begin()+1,player1_hand.end(),player1_hand.begin())){
        cout &#x3C;&#x3C; &#x22;   &#x22; &#x3C;&#x3C; &#x22;Player 1 has kemps&#x22; &#x3C;&#x3C; endl;
    }
    
    cout &#x3C;&#x3C; &#x22;Player 2&#x27;s Hand: &#x22; &#x3C;&#x3C; endl;
    for(int i=0;i&#x3C;4;i++){
        cout &#x3C;&#x3C; &#x22;   &#x22; &#x3C;&#x3C; player2_hand[i] &#x3C;&#x3C; endl;
    }
    if(equal(player1_hand.begin()+1,player1_hand.end(),player1_hand.begin())){
        cout &#x3C;&#x3C; &#x22;   &#x22; &#x3C;&#x3C; &#x22;Player 2 has kemps&#x22; &#x3C;&#x3C; endl;
    }
    
    cout &#x3C;&#x3C; &#x22;Player 3&#x27;s Hand: &#x22; &#x3C;&#x3C; endl;
    for(int i=0;i&#x3C;4;i++){
        cout &#x3C;&#x3C; &#x22;   &#x22; &#x3C;&#x3C; player3_hand[i] &#x3C;&#x3C; endl;
    }
    if(equal(player1_hand.begin()+1,player1_hand.end(),player1_hand.begin())){
        cout &#x3C;&#x3C; &#x22;   &#x22; &#x3C;&#x3C; &#x22;Player 3 has kemps&#x22; &#x3C;&#x3C; endl;
    }
    
    cout &#x3C;&#x3C; &#x22;Player 4&#x27;s Hand: &#x22; &#x3C;&#x3C; endl;
    for(int i=0;i&#x3C;4;i++){
        cout &#x3C;&#x3C; &#x22;   &#x22; &#x3C;&#x3C; player4_hand[i] &#x3C;&#x3C; endl;
    }
    if(equal(player1_hand.begin()+1,player1_hand.end(),player1_hand.begin())){
        cout &#x3C;&#x3C; &#x22;   &#x22; &#x3C;&#x3C; &#x22;Player 4 has kemps&#x22; &#x3C;&#x3C; endl;
    }
    
    return 0;
}
</code></pre>
This program outputs:
<pre><code>
Player 1's Hand: 
   4
   6
   A
   K
Player 2's Hand: 
   7
   7
   7
   7
   Player 2 has kemps
Player 3's Hand: 
   J
   2
   8
   A
Player 4's Hand: 
   Q
   2
   4
   J
</code></pre>

<h2 id="terminate">Terminate</h2>
<h3>Description</h3>
Terminate is called automatically in a C++ program when there is an unhandled exception. The function "set_terminate()" 
allows you to set which function gets called on terminate. 
<h3>Example</h3>
<pre><code>#include &#x3C;iostream&#x3E;
#include &#x3C;vector&#x3E;

using namespace std;

void handle(){
    cout &#x3C;&#x3C; &#x22;Exception thrown but nothing to catch it...&#x22; &#x3C;&#x3C; endl;
}

int main(){
    set_terminate(handle);
    
    vector&#x3C;int&#x3E; p;
    p.at(0);
    
    return 0;
}
</code></pre>
This program outputs:
<pre><code>
Exception thrown but nothing to catch it...
bash: line 7: 15928 Aborted                 (core dumped) ./a.out
</code></pre>

<h2 id="type_generics">Type Generics</h2>
<h3>Description</h3>
Allows you write code without stating the actual data type. The use of generics is commonly seen in data structures like array and vector. Generics make our code more reusable.
<h3>Example</h3>
<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;

using namespace std;

template &lt;typename T&gt; T myAbs(T a){
    if(a &lt; 1) a *= -1;
    return a;
}

int main(){
    double x = -1.2;
    int y = 100;
    float z = -20.9;
    
    cout &lt;&lt; myAbs(x) &lt;&lt; endl;
    cout &lt;&lt; myAbs(y) &lt;&lt; endl;
    cout &lt;&lt; myAbs(z) &lt;&lt; endl;
}
</code></pre>
This program outputs:
<pre><code>1.2
100
20.9
</code></pre>

<h2 id="unique_locks">Unique Locks</h2>
<h3>Description</h3>
Unique locks on construction locks a mutex and on destruction unlocks a mutex. Unique locks
differs from lock guards, because they can be unlocked.
<h3>Example</h3>
<pre><code>#include &#x3C;iostream&#x3E;
#include &#x3C;mutex&#x3E;
#include &#x3C;thread&#x3E;
#include &#x3C;vector&#x3E;
#include &#x3C;unistd.h&#x3E;

using namespace std;

mutex m;

int main() {
    
    vector&#x3C;thread&#x3E; threads;
    
    for(int i=0;i&#x3C;10;i++){
        threads.push_back( 
            thread([i]{
                unique_lock&#x3C;mutex&#x3E; ul(m);
                cout &#x3C;&#x3C; i &#x3C;&#x3C; &#x22;&#x27;s critical&#x22;;
                usleep(1*100);
                cout &#x3C;&#x3C; &#x22; section&#x22;;
                usleep(1*100);
                cout &#x3C;&#x3C; endl;
                usleep(1*100);
            })
        );
    }
    
    for(int i=0;i&#x3C;10;i++){
        threads[i].join();
    }

    return 0;
}
</code></pre>

This program outputs:
<pre><code>0's critical section                                                              
3's critical section                                            
4's critical section                                           
5's critical section                                            
6's critical section                                           
7's critical section                                            
8's critical section                                            
2's critical section                                           
1's critical section                                            
9's critical section
</code></pre>

<h2 id="threads">Threads</h2>
<h3>Description</h3>
A sequence of instructions which can be executed concurrently. Each thread is 
given a function to run and parameters for its function. A join function is used to
finish the thread and collect its returned data. Threads have the risks of errors
due to things like race condidtions. However concurrency can greatly improve the
run time of your program.
<h3>Example</h3>
<pre><code>#include &lt;iostream&gt;
#include &lt;cstdlib&gt;
#include &lt;pthread.h&gt;

using namespace std;

const uint NUM_THREADS = 5;

//Data for each thread
struct thread_data{
  int thread_id;
  int input;
};

//Function which each thread will do
void *calc_part(void *input) {

  thread_data* ptr = (thread_data*)input;
  int n = ptr-&gt;thread_id;
  int m = ptr-&gt;input;

  int* thread_sum = (int*)malloc(sizeof(int));

  thread_sum[0] = 1;

  for(int i=1;i&lt;=m;i++){
    if(i%NUM_THREADS == n){
      thread_sum[0] *= i;
    }
  }

  //Using printf instead to prevent race conditions
  printf(&quot;  Thread  #%d returns %dn&quot;,n,thread_sum[0]);
  pthread_exit(thread_sum);
}

int factorial(int x){

  cout &lt;&lt; &quot;Input is &quot; &lt;&lt; x &lt;&lt; endl;

  if(x==0){
    cout &lt;&lt; &quot;Output is 0&quot; &lt;&lt; endl;
    return 0;
  }

  int output = 1;

  pthread_t threads[NUM_THREADS];

  int** results = (int**)malloc(sizeof(int) * NUM_THREADS);

  //Setting up the data for each thread
  thread_data* thread_datas = (thread_data*)malloc(sizeof(thread_data) * NUM_THREADS);
  for(int i = 0; i &lt; NUM_THREADS; i++) {
    thread_data d; 
    d.thread_id = i;
    d.input = x;
    thread_datas[i] = d;
  }

  //Starting each thread
  for(int i = 0; i &lt; NUM_THREADS; i++) {
    pthread_create(&amp;threads[i], NULL, calc_part, &amp;thread_datas[i]);
  }

  //Stopping and collecting data from each thread
  for(int i = 0; i &lt; NUM_THREADS; i++) {
    pthread_join(threads[i], (void**)&amp;results[i]);
    output *= results[i][0];
  }

  cout &lt;&lt; &quot;Output is &quot; &lt;&lt; output &lt;&lt; endl;
  return output;
}

int main () {
  factorial(1);
  factorial(2);
  factorial(5);
  factorial(10);
}
</code></pre>

This program outputs:
<pre><code>Input is 1
  Thread  #1 returns 1
  Thread  #2 returns 1
  Thread  #0 returns 1
  Thread  #3 returns 1
  Thread  #4 returns 1
Output is 1
Input is 2
  Thread  #0 returns 1
  Thread  #3 returns 1
  Thread  #4 returns 1
  Thread  #2 returns 2
  Thread  #1 returns 1
Output is 2
Input is 5
  Thread  #4 returns 4
  Thread  #2 returns 2
  Thread  #3 returns 3
  Thread  #1 returns 1
  Thread  #0 returns 5
Output is 120
Input is 10
  Thread  #2 returns 14
  Thread  #1 returns 6
  Thread  #0 returns 50
  Thread  #3 returns 24
  Thread  #4 returns 36
Output is 3628800
</code></pre>

<h2 id="thread_safe_functions">What makes a function "thread-safe"?</h2>
<h3>Description</h3>

Functions are thread-safe if they behave correctly during simultaneous executions of threads. The risk of a function not being thread safe comes entirely from data sharing. The easiest way to have a function be thread-safe is to have each thread only use private data or data which is handled with atomic operations. If non-atomic shared data is needed among the threads, the engineer must use mutual exclusion. Mutual exclusion opens a Pandora's box of possible bugs into your software including: deadlocks, race conditions, and starvation. If you must use threads, follow the K.I.S.S. principle: Keep It Simple Stupid!

<h3>Example</h3>
<pre><code>#include &lt;stdlib.h&gt;
#include &lt;thread&gt;
#include &lt;mutex&gt;
#include &lt;iostream&gt;
#include &lt;atomic&gt;
#include &lt;vector&gt;
#include &lt;string&gt; 
#include &lt;unistd.h&gt;

using namespace std;

//Local data only
void print_index(int size){
    
    vector&lt;thread&gt; t;
    
    for(int i=0;i&lt;size;i++){
        t.push_back(thread([i]{
            cout &lt;&lt; (to_string(i) + &quot; &quot;);
            sleep(1);
        }));
    }
    
    for(int i=0;i&lt;size;i++){
        t[i].join();
    }
    cout &lt;&lt; endl;
}

//Atomic operation only
int series_sum(int size){
    
    atomic&lt;int&gt; output = 0;
    
    vector&lt;thread&gt; t;
    
    for(int i=0;i&lt;size;i++){
        t.push_back(thread([&amp;output,i]{
            output += i;
        }));
    }
    
    for(int i=0;i&lt;size;i++){
        t[i].join();
    }
    
    return output;
}

//Mutual Exclusions
int series_product(int size){
    
    int output = 1;
    
    vector&lt;thread&gt; t;
    
    mutex m1;
    
    for(int i=1;i&lt;=size;i++){
        t.push_back(thread([&amp;output,i,&amp;m1]{
            lock_guard&lt;mutex&gt; g1(m1);
            output *= i;
        }));
    }
    
    for(int i=0;i&lt;size;i++){
        t[i].join();
    }
    
    return output;
}

int main(){
    print_index(10);
    cout &lt;&lt; series_sum(1000) &lt;&lt; endl;
    cout &lt;&lt; series_product(10) &lt;&lt; endl;
}
</code></pre>
This program outputs:
<pre><code>1 0 2 3 4 5 6 7 8 9 
499500
3628800
</code></pre>

<h2 id="vector_vs_list_vs_array">Vector vs List vs Array</h2>
<h3>Description</h3>
<li>Lists are doubly linked lists which have O(1) insert and deletion times and O(N) random access time. Their elements may not be in order in memory and are best when you have to store a fixed number of large objects.</li>
<li>Vectors are dynamic arrays which have O(N) insert and deletion times and O(1) random access time. Their elements are in order and are best for storing many small objects that are randomly accessed often.</li>
<li>Arrays are inherited from C. They are similar to vectors except they are not resizable, more compact, and don't require STL headers.</li>
<h3>Example</h3>
<pre><code>#include &#x3C;iostream&#x3E;
#include &#x3C;vector&#x3E;
#include &#x3C;list&#x3E;
using namespace std;

int main() {
&#x9;
&#x9;
&#x9;vector&#x3C;int&#x3E; v;
&#x9;list&#x3C;int&#x3E; l;
&#x9;int a[10]; //statically allocated
&#x9;
&#x9;for(int i=0;i&#x3C;10;i++){
&#x9;    v.push_back(i);
&#x9;    l.push_back(i);
&#x9;    a[i] = i;
&#x9;}
&#x9;
&#x9;for(int i=0;i&#x3C;10;i++){
&#x9;    cout &#x3C;&#x3C; &#x22;vector: &#x22; &#x3C;&#x3C; v[i] &#x3C;&#x3C;
&#x9;    &#x22; list: &#x22; &#x3C;&#x3C; *l.begin()+i &#x3C;&#x3C;
&#x9;    &#x22; array: &#x22; &#x3C;&#x3C; a[i] &#x3C;&#x3C; endl;
&#x9;}
&#x9;
&#x9;return 0;
}
</code></pre>
This program outputs:
<pre><code>vector: 0 list: 0 array: 0
vector: 1 list: 1 array: 1
vector: 2 list: 2 array: 2
vector: 3 list: 3 array: 3
vector: 4 list: 4 array: 4
vector: 5 list: 5 array: 5
vector: 6 list: 6 array: 6
vector: 7 list: 7 array: 7
vector: 8 list: 8 array: 8
vector: 9 list: 9 array: 9
</code></pre>

<h2 id="virtual">Virtual</h2>
<h3>Description</h3>
Virtual functions are functions which are defined at runtime. This is called late-binding. They differ from normal functions, because normal function are defined at compile time AKA early-binding. Because virtual functions use late binding, they are overridable and are able to benefit from polymorphism. The implementation of the virtual method is decided by the pointer which you call it through.
<h3>Example</h3>
<pre><code>#include &#x3C;iostream&#x3E;

using namespace std;

class base{
    public:
        virtual void print_name(){
            cout &#x3C;&#x3C; &#x22;base&#x22; &#x3C;&#x3C; endl;
        };
        
        void print_name_non_virtual(){
           cout &#x3C;&#x3C; &#x22;base&#x22; &#x3C;&#x3C; endl;
        };
};

class derived : public base{
    
    public:
        void print_name(){
            cout &#x3C;&#x3C; &#x22;derived&#x22; &#x3C;&#x3C; endl;
        };  
        
        void print_name_non_virtual(){
           cout &#x3C;&#x3C; &#x22;derived&#x22; &#x3C;&#x3C; endl;
        };
};

int main(){

    derived d;
    base* bptr = &#x26;d;
    
    bptr-&#x3E;print_name(); //derived
    bptr-&#x3E;print_name_non_virtual(); //base
    bptr-&#x3E;base::print_name_non_virtual(); //base

    return 0;
}
</code></pre>
This program outputs:
<pre><code>
derived
base
base
</code></pre>

<h2 id="volatile">Volatile</h2>
<h3>Description</h3>
Prevents the addresses from being optimized away. Volatile is needed for embedded development where the hardware device is memory-mapped and memory may change without the compilier knowing.
<h3>Example</h3>
<pre><code>int main(){
    
    //The compiler may optimize the while loop into &quot;while(true)&quot;
    int a = 100;
    while(a == 100){}
    
    //The compliler will not &quot;optimize away&quot; the b variable
    volatile int b = 100;
    while(b == 100){}
} 
</code></pre>
